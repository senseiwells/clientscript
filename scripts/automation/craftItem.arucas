import * from Minecraft;
import Assert, VarArgs from util.Auxilary;
import * from util.Json;
import Predicate from util.Predicates;
import StringUtil from util.StringUtils;


SCRIPT_PREFIX = "craftItem_";
// Job types:
// Find item 
// Search recipes
// Access crafting table
// Craft item
// Store item

// Configurable:
// Storable locations
// Crafting targets

// global restriction map that stores all restrictions.
// this is strict json that does not allow trailing ','
RESTRICTION_MAP = {
    // reach distance is 5 blocks.
    "reach_distance" : 5,
    // max tries before screen inventory query is cancelled.
    "max_tries" : 10,
    "CRAFTING_TREE" : false, // if true, use crafting tree to find recipes. if false, use recipe book.
    "warn_level" : 1, // 0: print debug, warn, error , 1: print warn and error, 2: print error only
    "use_actionbar" : false // use actionbar to display messages. if false, use print.
};

// var that is reset whenever script is loaded
LastInteractedBlockPos = null;
STORAGE = null; // MergedInventory of all storage locations
STORAGE_LOCATIONS = {}; // list of storage locations

DEBUG_FLAG = true; // Throw error when true, else just print error message.

fun createStorage(){
    // get player world, access STORAGE_LOCATIONS by world fullId, and add all storage locations to storage.
    STORAGE = MergedInventory.ofPositions(STORAGE_LOCATIONS[Player.get().getWorld().getFullId()]);
}

fun addInventory(pos){
    // if storage is not initialized, initialize it.
    if (STORAGE == null) {
        createStorage();
    }
    // add inventory
    STORAGE.addInventory(pos);
    // add location to STORAGE_LOCATIONS, if not initialized then initialize it.
    if (STORAGE_LOCATIONS[Player.get().getWorld().getFullId()] == null) {
        STORAGE_LOCATIONS[Player.get().getWorld().getFullId()] = [];
    }
    STORAGE_LOCATIONS[Player.get().getWorld().getFullId()].append(pos);
}

// class Logger
class Logger {

    static var COUNTER = 0;
    // can't be initialized.
    Logger(){
        throw new Error("Logger cannot be initialized.");
    }
    static fun info(message) {
        // always 
        Logger.print(message);
    }
    //static fun debug(message : String)
    static fun debug(message) {
        if (RESTRICTION_MAP["warn_level"] <= 0) {
            Logger.print(message);
        }
    }
    //static fun warn(message : String)
    static fun warn(message) {
        if (RESTRICTION_MAP["warn_level"] <= 1) {
            Logger.print(message);
        }
    }
    //static fun error(message : String)
    static fun error(message) {
        if (RESTRICTION_MAP["warn_level"] <= 2) {
            Logger.print(message);
        }
    }
    // static fun print(message : String)
    static fun print(message) {
        if (RESTRICTION_MAP["use_actionbar"]) {
            Player.get().messageActionBar(message);
        } else {
            print(message);
        }
    }
    static fun actionCounter(){
        Logger.COUNTER++;
        Player.get().messageActionBar("Action " + Logger.COUNTER);
    }

    static fun actionCounter(message) {
        Logger.COUNTER++;
        Player.get().messageActionBar("Action " + Logger.COUNTER + ": " + message);
    }
    static fun resetCounter(){
        Logger.COUNTER = 0;
    }
}

// global RenderManager that stores all rendered boxes.
// it inherits from List, so it can be iterated over.
// it also has a render function that renders all boxes in the list.
// it also has a clear function that clears the list., but we always stop rendering for all boxes when the list is cleared.
// for utility, we have getBoxes(key) that returns a list of boxes with the given key.
class RenderManager : List {
    // map of {key : list of boxes} that stores all boxes that are rendered.
    static var Boxes = {};
    var boxes = [];
    // when we construct a new RenderManager, it should be defined with a key.
    // this key is used to identify the boxes that are rendered.
    RenderManager(key : String) : super() {
        // initialize boxes with empty list.
        this.boxes = [];
        // add boxes to Boxes map if there were no boxes with the given key.
        // else, add the boxes to the list of boxes with the given key.
        if (RenderManager.Boxes[key] != null) {
            RenderManager.Boxes[key].addAll(this.boxes);
        } else {
            RenderManager.Boxes[key] = this.boxes;
        }
    }

    // static method to directly add a box to the Boxes map.
    static fun addBox(key : String, box : BoxShape) {
        // if there were no boxes with the given key, initialize the list with the given box.
        // else, append the box to the list of boxes with the given key.
        if (RenderManager.Boxes[key] != null) {
            RenderManager.Boxes[key].append(box);
        } else {
            RenderManager.Boxes[key] = [box];
        }
    }

    // override add function to add box to the Boxes map.
    fun append(box : BoxShape) : Boolean {
        // append to boxes list.
        this.boxes.add(box);
        // also append to Boxes map.
        RenderManager.Boxes[this.key].append(box);
        return super.append(box);
    }

    // override addAll function to add all boxes to the Boxes map.
    fun addAll(boxes : Iterable) : Boolean {
        // we can use add function to add all boxes to the Boxes map.
        foreach (box : boxes) {
            this.append(box);
        }
    }

    // override clear function to clear all boxes in the Boxes map.
    fun clear() {
        // stop rendering for all boxes.
        foreach (box : this.boxes) {
            box.stopRendering();
        }
        // clear boxes list.
        this.boxes.clear();
    }

    // static clearKey(key) function that clears all boxes with the given key.
    static fun clearKey(key : String) {
        // stop rendering for all boxes.
        RenderManager.stopRendering(key);
        RenderManager.Boxes[key].clear();
        // now remove the key from the Boxes map.
        RenderManager.Boxes.remove(key);
    }

    // static fun stopRendering(key) that stops rendering for all boxes with the given key. But it does not clear the list.
    static fun stopRendering(key : String) {
        foreach (box : RenderManager.Boxes[key]) {
            box.stopRendering();
        }
    }
    // static fun startRendering(key) that starts rendering for all boxes with the given key.
    static fun startRendering(key : String) {
        foreach (box : RenderManager.Boxes[key]) {
            box.render();
        }
    }
}

class ItemUtil {
    static var NULL_NBT = "NULL";
    static var isEmpty = fun(item) {
        return item == null || item.getCount() == 0;
    };

    static fun getFullId(item : ItemStack | String) {
        if (item.instanceOf(String.type)) {
            return item;
        }
        return item.getFullId();
    }
    static fun getNbt(item : ItemStack) {
        targetValue = item.getNbt();
        if (targetValue == null || targetValue == {}) {
            return ItemUtil.NULL_NBT;
        }
        return targetValue;
    }
    // merges two items and returns the merged item.
    static fun mergeStacks(item1, item2) {
        // if either one of items is null, return the other one.
        if (item1 == null || item1.getCount() == 0) {
            return item2;
        } else if (item2 == null|| item2.getCount() == 0) {
            return item1;
        }
        Assert.assert(item1.getFullId() == item2.getFullId(), "Cannot merge items with different names, item 1: " + item1.getFullId() + ", item 2: " + item2.getFullId());
        // assert if nbt is equal, if both are empty map, then they are equal, else use isNbtEqual.
        Assert.assert(ItemUtil.getNbt(item1) == ItemUtil.getNbt(item2) || item1.isNbtEqual(item2), "Cannot merge items with different nbt");
        // create new item with count of item1 + item2.
        // for backward compatibility, we don't use copy constructor.
        newItem = ItemStack.of(item1.getFullId());
        // copy nbt
        newItem.setNbt(item1.getNbt());
        newItem.setStackSize(item1.getCount() + item2.getCount());
        // assert new item is not null.
        return newItem;
    }
    // compares name and nbt of two items. returns if they are equal.
    static fun areEqualIncludeNbt(item1 : ItemStack, item2 : ItemStack) : Boolean {
        return item1.getFullId() == item2.getFullId() && ItemUtil.getNbt(item1) == ItemUtil.getNbt(item2);
    }

    // compares nbt if first item has nbt that is not empty. or, compare name and return the result.
    static fun areEqualIgnoreNbt(item1 : ItemStack, item2 : ItemStack) : Boolean {
        if (ItemUtil.getNbt(item1) != ItemUtil.NULL_NBT) {
            return ItemUtil.getNbt(item1) == ItemUtil.getNbt(item2);
        }
        return item1.getFullId() == item2.getFullId();
    }
    static fun copy(item : ItemStack | Null) : ItemStack | Null{
        if (item == null) {
            return null;
        }
        // return copy(item, item.getStackSize());
        return ItemUtil.copy(item, item.getCount());
    }
    // copy item with given count.
    static fun copy(item : ItemStack | Null, count : Number) : ItemStack | Null{
        if (item == null || item.getCount() == 0) {
            return null;
        }
        Assert.assert(count > 0, " Count must be greater than 0. ");
        newItem = ItemStack.of(item.getFullId());
        newItem.setStackSize(count);
        newItem.setNbt(item.getNbt());
        return newItem;
    }

    static fun of(item : ItemStack | String, count : Number) : ItemStack {
        if (Type.of(item) == ItemStack.type) {
            return ItemUtil.copy(item, count);
        }
        newItem = ItemStack.of(item);
        newItem.setStackSize(count);
        return newItem;
    }

    static fun of(item : ItemStack | String) : ItemStack {
        if (Type.of(item) == ItemStack.type) {
            return ItemUtil.copy(item);
        }
        return ItemStack.of(item);
    }
}
class ItemStackMap : Map {
    // this should be private.
    // map of {name : {nbt : item}}.
    var StrictNameMap = {};

    ItemStackMap(values : Iterable) : super() {
        foreach (vals : values) {
            Assert.assert(Type.of(vals) == ItemStack.type, "ItemStackMap can only contain ItemStacks");
            this.add(vals);
        }
    }
    // default constructor.
    ItemStackMap() : super() {
        this.StrictNameMap = {};
    }

    fun clone(){
        // to iterable
        iterable = this.iterator();
        // create new map
        newMap = new ItemStackMap(iterable);
        return newMap;
    }

    // stringify
    fun toString() : String {
        return "ItemStackMap: " + this.StrictNameMap;
    }

    // find item then decrement count if found. returns amount of item decremented, or 0 if not found. clears entry if map is empty.
    // if item was present but count was greater than available, throws error.
    fun decrement(item : ItemStack | Null) : Number {
        // if item is null, return 0.
        if (item == null) {
            return 0;
        }
        // get item and check if its null.
        itemName = item.getFullId();
        itemNbt = ItemUtil.getNbt(item);
        containedItem = this.get(item);
        if (containedItem != null) {
            // check amount to decease. if amount is greater than count, throw error.
            Assert.assert(item.getCount() <= containedItem.getCount(), "Cannot take more items than available");
            // now we can safely decrease count.
            containedItem.setStackSize(containedItem.getCount() - item.getCount());
            // check if count is 0, if so remove entry.
            if (containedItem.getCount() == 0) {
                this.StrictNameMap[itemName].remove(itemNbt);
            }
            // check if map is empty, if so clear it.
            if (len(this.StrictNameMap[itemName]) == 0) {
                this.StrictNameMap.remove(itemName);
            }
            // return amount decreased.
            return item.getCount();
        }
        return 0;
    }

    // increment count of item if found, else add item to map.
    fun increment(item : ItemStack | Null, amount : Number) : Number {
        // if item is null, return 0.
        if (item == null) {
            return 0;
        }
        // get item and check if its null.
        containedItem = this.get(item);
        if (containedItem != null) {
            containedItem.setStackSize(containedItem.getCount() + item.getCount());
        } else {
            // add item to map.
            // copy item.
            item = ItemUtil.copy(item, amount);
            this.addToMap(item);
        }
        // return amount increased.
        return amount;
    }
    // takes items and returns new list that were not fully taken.
    fun takeAll(items : List) : List {
        returnValue = [];
        foreach (item : items) {
            decremented = this.decrement(item);
            if (decremented < item.getCount()) {
                // add item to return value.
                newItem = ItemUtil.copy(item, item.getCount() - decremented);
                returnValue.append(newItem);
            }
        }
        return returnValue;
    }

    // force decrease. Returns successfully decreased amount.
    fun take(item : ItemStack| Null) : Number {
        // if item is null, return 0.
        if (item == null) {
            return 0;
        }
        // get item and check if its null.
        containedItem = this.get(item);
        if (containedItem != null) {
            // check amount to decease. get min of count and item.getCount().
            amount = Math.min(item.getCount(), containedItem.getCount());
            // now we can safely decrease count.
            containedItem.setStackSize(containedItem.getCount() - amount);
            // check if count is 0, if so remove entry.
            if (containedItem.getCount() == 0) {
                // remove key
                // assert this.StrictNameMap[item.getFullId()] is not null first
                Assert.assert(this.StrictNameMap[item.getFullId()] != null, "Cannot remove item " + item.getFullId() + " from map");
                this.StrictNameMap[item.getFullId()].remove(ItemUtil.getNbt(item));
            }
            // check if map is empty, if so clear it.
            if (len(this.StrictNameMap[item.getFullId()]) == 0) {
                // remove key
                this.StrictNameMap.remove(item.getFullId());
            }
            // return amount decreased.
            return amount;
        }
        return 0;
    }

    // creates {name : {nbt : item}} map.
    // this should be private.
    fun addToMap(item) {
        itemNbt = ItemUtil.getNbt(item);
        // assert nbt is not null.
        Assert.assert(itemNbt != null, "Cannot add item with null nbt");
        if (this.StrictNameMap[item.getFullId()] != null) {
            // access and merge item.
            holdingItem = this.get(item);
            this.StrictNameMap[item.getFullId()][itemNbt] = ItemUtil.mergeStacks(holdingItem, item);
        } else {
            //create new map.
            this.StrictNameMap[item.getFullId()] = {itemNbt : ItemUtil.copy(item)};
        }
    }

    fun get(item : ItemStack | Null) : ItemStack | Null{
        // if item is null, return null.
        if (item == null) {
            return null;
        }
        // access StrictNameMap and return item.
        itemNbt = ItemUtil.getNbt(item);
        if (this.StrictNameMap[item.getFullId()] != null) {
            if (this.StrictNameMap[item.getFullId()][itemNbt] != null) {
                return this.StrictNameMap[item.getFullId()][itemNbt];
            }
        }
        return null;
    }

    // override methods.
    fun add(item : ItemStack | Null) {
        // if item is null, return.
        if (item == null) {
            return;
        }
        this.addToMap(item);
    }

    fun contains(item : ItemStack | String) : Boolean {
        if (item.instanceOf(String.type)) {
            return this.StrictNameMap[item] != null;
        }
        // access StrictNameMap and check if item is present.
        if (this.get(item) != null) {
            return true;
        }
        return false;
    }

    fun containsKey(item : ItemStack) : Boolean {
        return this.contains(item);
    }

    // get Count for item.
    fun getCount(item : ItemStack) : Number {
        containedItem = this.get(item);
        if (containedItem != null) {
            return containedItem.getCount();
        }
        return 0;
    }

    fun clear(){
        this.StrictNameMap = {};
    }
    // put item in map.
    operator [] (index, value) {
        // index may be ItemStack or length 2 list of name and nbt.
        if (Type.of(index) == ItemStack.type) {
            this.add(index);
        } else if (Type.of(index) == List.type) {
            // assert that index is length 2 list.
            Assert.assert(len(index) == 2, "Index must be length 2 list of name and nbt");
            // create new item and add it.
            stack = Material.of(index[0]).asItemStack();
            stack.setNbt(index[1]);
            this.add(stack);
        } else {
            Assert.assert(false, "Index must be ItemStack or length 2 list of name and nbt");
        }
    }
    // access item in map.
    operator [] (index) {
        // index may be ItemStack or length 2 list of name and nbt.
        if (Type.of(index) == ItemStack.type) {
            return this.get(index);
        } else if (Type.of(index) == List.type) {
            // assert that index is length 2 list.
            Assert.assert(len(index) == 2, "Index must be length 2 list of name and nbt");
            // create new item and add it.
            stack = Material.of(index[0]).asItemStack();
            stack.setNbt(index[1]);
            return this.get(stack);
        } else {
            Assert.assert(false, "Index must be ItemStack or length 2 list of name and nbt");
        }
    }

    fun put(key, value) {
        this[key] = value;
    }

    fun putAll(values : Map) {
        foreach (vals : values) {
            this[vals] = values[vals];
        }
    }
    fun putIfAbsent(key, value) {
        if (this[key] == null) {
            this[key] = value;
        }
    }
    fun remove(key) {
        this.StrictNameMap.remove(key);
    }

    // searches through map and merges items into list
    fun getValues() {
        // create list to return.
        list = [];
        // iterate through StrictNameMap.
        foreach (name : this.StrictNameMap) {
            foreach (nbt : this.StrictNameMap[name]) {
                // add item to list if it is not null.
                if (this.StrictNameMap[name][nbt] != null) {
                    list.append(this.StrictNameMap[name][nbt]);
                }
            }
        }
        // return list.
        return list;
    }

    fun isEmpty(){
        return this.getValues().isEmpty();
    }

    // searches through map and merges valid pair into list
    fun getKeys(){
        // create list to return.
        list = [];
        // iterate through StrictNameMap.
        foreach (name : this.StrictNameMap) {
            foreach (nbt : this.StrictNameMap[name]) {
                // add item to list if it is not null.
                if (this.StrictNameMap[name][nbt] != null) {
                    list.append([name, nbt]);
                }
            }
        }
        // return list.
        return list;
    }

    // iterable
    fun iterator() : Iterator {
        // returns value iterator of StrictNameMap.
        return this.StrictNameMap.getValues().iterator();
    }
}

/**
 * This error is thrown when Iteration should stop.
 */

class StopIteration : Error {
    StopIteration(): super();
}


class LazyOptional {
    // We use this class to store optional values.
    // whenever access happens, we check if value is present.
    // if value is present, return it.
    // else, calculate value and return it.
    var constructor : Function | Null;
    var condition : Function | Null = fun (){return true;};
    var value;
    var isPresent : Boolean = false;

    LazyOptional(value) {
        // just wrapped value, no condition.
        this.value = value;
        this.isPresent = true;
    }

    LazyOptional(constructor : Function, condition : Function) {
        // constructor is a function that returns value.
        this.constructor = constructor;
        // condition is a function that checks if we can calculate value.
        // if condition is true, calculate value and set isPresent to true.
        if (condition()) {
            this.value = this.constructor();
            this.isPresent = true;
        }
        else {
            this.condition = condition;
        }
        // value is null
        this.value = null;
    }

    // static fun of(value) -> LazyOptional
    static fun of(value) {
        return new LazyOptional(value);
    }

    fun get() {
        // if value is present, return it.
        if (this.isPresent) {
            return this.value;
        }
        // else, check condition
        else {
            // if condition is true, calculate value and set isPresent to true.
            if (this.condition()) {
                this.value = this.constructor();
                this.isPresent = true;
                return this.value;
            }
            // else, return null
            else {
                return null;
            }
        }
    }
}


fun examplePrimeSupplier(){
    // this is value to return. This should be defined locally.
    currentNumber = 2;
    // efficient isPrime function that only checks until sqrt(number).
    // The function does not necessarily need to be defined inside the lambda.
    fun isPrime(number : Number){
        if (number == 2){
            return true;
        }
        if (Math.mod(number, 2) == 0){
            return false;
        }
        for (i = 3; i <= number ^ 0.5 + 1; i += 2){
            if (Math.mod(number, i) == 0){
                return false;
            }
        }
        return true;
    }
    // inside this lambda we can access currentNumber, and modify it.
    supplier = fun(args...){
        while (true){
            currentNumber++;
            if (isPrime(currentNumber)){
                // lambda may return value or null.
                return currentNumber;
            }
        }

    };
    // we return a pair of functions, the first is the supplier, the second is the valueAccessor.
    return [supplier, fun (){return currentNumber;}];
}

// class YieldIterable is python generator equivalent. It takes a supplier and a valueAccessor.
// supplier is a function that modifies the value, it does not have to return anything. But it should modify the value defined in outer scope.
// valueAccessor is a function that accesses the value which is modified by supplier.
// in examplePrimeSupplier, the supplier is the while loop, and the valueAccessor is the return statement that returns currentNumber.
class YieldIterable : Iterable{
    var supplier: Function;
    var valueAccessor: Function;

    YieldIterable(varargs) : super() {
        // assert length is 2.
        Assert.assert(len(varargs) == 2, "YieldIterable constructor takes 2 arguments but " + len(varargs) + " arguments were given. ");
        this.supplier = varargs[0];
        this.valueAccessor = varargs[1];
        
    }

    YieldIterable(supplier, valueAccessor) : super() {
        this.supplier = supplier;
        this.valueAccessor = valueAccessor;
    }

    fun iterator() {
        return new YieldIterator(this.supplier, this.valueAccessor);
    }

}

class YieldIterator : Iterator {
    static var NULL_PROVIDER = fun (){return null;};
    static var NOT_INITIALIZED = fun (){return null;};
    var supplier: Function;
    var valueAccessor: Function;
    var nextResult = YieldIterator.NOT_INITIALIZED;

    YieldIterator(supplier : Function, valueAccessor : Function) : super() {
        this.supplier = supplier;
        this.valueAccessor = valueAccessor;
    }

    fun hasNext() {
        this.initialize();
        if (this.nextResult != YieldIterator.NULL_PROVIDER) {
            return true;
        }
        return false;
    }
    // initialize nextResult. 
    fun initialize() {
        if (this.nextResult == YieldIterator.NOT_INITIALIZED) {
            try {
                this.supplier();
                this.nextResult = this.valueAccessor();
            }
            catch (e) {
                this.nextResult = YieldIterator.NULL_PROVIDER;
            }
        }
    }
    // return next value. if nextResult was not initialized, initialize it.
    fun next() {
        this.initialize();
        valueToReturn = this.nextResult;
        try {
            this.supplier();
            this.nextResult = this.valueAccessor();
        }
        catch (e) {
            // check if StopIteration was thrown.
            if (e.instanceOf(StopIteration.type)){
                // if StopIteration was thrown, set nextResult to NULL_PROVIDER.
                this.nextResult = YieldIterator.NULL_PROVIDER;
            }
            else {
                // if StopIteration was not thrown, rethrow the exception.
                throw e;
            }
            this.nextResult = YieldIterator.NULL_PROVIDER;
        }
        return valueToReturn;
    }
}

// function that creates [[1,4,9],...] from [[1,2,3],[4,5,6],[9,4,2]], which is combination of all elements in each list.
// recursively collects all combinations of elements in each list.
// yield is far more efficient than this, due to memory allocation.
fun expensiveCombination(array : List) : List{
    array = array.filter(fun (x){return !x.isEmpty();});
    collected = [];
    if (array.isEmpty()) {
        return collected;
    }
    else {
        // get first element of array and remove it.
        first = array[0];
        // sliced = array.slice(range(1, len(array))); - this is not working. backward compatibility issue.
        sliced = [];
        for (i = 1; i < len(array); i++) {
            sliced.append(array[i]);
        }
        // get combinations of sliced.
        combinations = expensiveCombination(sliced);
        foreach (firstElements : first) {
            if (combinations.isEmpty()) {
                collected.append([firstElements]);
            }
            else {
                foreach (combination : combinations) {
                    arr = [firstElements];
                    arr.addAll(combination);
                    collected.append(arr);
                }
            }
        }
    }
    return collected;
}

class CombinedIterable : Iterable {
    var array: List;
    var maxSize : Number;
    CombinedIterable(array : List) : super() {
        this.array = array.filter(fun (x){return !x.isEmpty();});
        this.maxSize = 1;
        for (i = 0; i < len(this.array); i++) {
            this.maxSize *= len(this.array[i]);
        }
    }

    fun size() : Number {
        return this.maxSize;
    }

    fun iterator() {
        return new CombinatedIterator(this.array);
    }
}
class CombinatedIterator : Iterator {

    var array : List = [];
    var idx : Number = 0; // index of current combination
    var maxidx : Number = 0; // calculates product of each list's length.
    CombinatedIterator(array : List) : super() {
        this.array = array;
        this.maxidx = 1;
        for (i = 0; i < len(array); i++) {
            this.maxidx *= len(array[i]);
        }
    }

    fun hasNext() : Boolean {
        return this.idx < this.maxidx;
    }

    fun next() {
        if (this.idx >= this.maxidx) {
            throw new StopIteration();
        }
        // get combination of idx.
        combination = [];
        idx = this.idx;
        for (i = 0; i < len(this.array); i++) {
            // we need divmod here. Math.mod() is working, so calculate mod, then subtract, then divide to get next index.
            j = Math.mod(idx, len(this.array[i]));
            idx -= j;
            idx /= len(this.array[i]);
            combination.append(this.array[i][j]);
        }
        this.idx += 1;
        return combination;
    }
}


interface MatchableInventory {
    fun match(itemStack: ItemStack): Number;
    fun matchPredicate(predicate: Function): Number;
    fun clone() : MatchableInventory ;
    fun getItems() : List ;
    fun getPlayerInventory() : MatchableInventory | Null;
}

// class Inventory
class AbstractInventory  : Iterable, MatchableInventory {
    var items: List;
    var size: Number;
    // var backEndMap is only used for cache.
    // Thus it may not reflect the actual state of the inventory.
    // It is used to speed up the process of searching for items.
    // we offer refresh() method to refresh the cache.
    var backEndMap : Map;

    // constructor
    AbstractInventory(size: Number) : super() {
        // initialize items list
        // we fill the list with nulls of size.
        this.items = [];
        for (i = 0; i < size; i++) {
            this.items.append(null);
        }
        // set size
        this.size = size;
        // set up backend set
        this.backEndMap = new ItemStackMap();
    }

    fun getPlayerInventory(){
        return null;
    }

    fun filterRecipeIngredients(ingredients : List) : List{
        // ingredients is [[itemStack, ...], []?, ...] where []? is optional empty list.
        // we want to return [[itemStack, ...], [itemStack],...] which only contains items that are in the inventory.
        cachedStacks = {}; // cache stacks to avoid contains() method if possible
        filteredIngredients = [];
        foreach (ingredient : ingredients) {
            if (ingredient.isEmpty()) {
                continue;
            }
            filteredIngredient = [];
            foreach (itemStack : ingredient) {
                stackId = itemStack.getFullId();
                if (cachedStacks.containsKey(stackId)) {
                    filteredIngredient.append(itemStack);
                }
                else if (this.contains(itemStack)) {
                    filteredIngredient.append(itemStack);
                    cachedStacks[stackId] = itemStack;
                }
            }
            filteredIngredients.append(filteredIngredient);
        }
        return filteredIngredients;
    }

    fun filterRecipe(recipe : Recipe) : List {
        // filter recipe ingredients
        filteredIngredients = this.filterRecipeIngredients(recipe.getIngredients());
        return filteredIngredients;
    }

    fun contains(item) : Boolean {
        itemFullId = null;
        if (item == null) {
            return false;
        }
        else if (item.instanceOf(ItemStack.type)) {
            itemFullId = item.getFullId();
        }
        else if (item.instanceOf(ImmutableItemStack.type)) {
            itemFullId = item.getFullId();
        }
        else {
            itemFullId = item;
        }
        return this.backEndMap.contains(itemFullId);
    }

    static fun of(){
        // cannot be instantiated
        throw new Error("Cannot instantiate AbstractInventory by method of().");
    }

    // implement Iterable
    fun iterator() : Iterator {
        return this.items.iterator();
    }

    // provide iterator for backend map
    fun mapIterator() : Iterator {
        return this.backEndMap.iterator();
    }

    // method getItems
    fun getItems(): List {
        // return list of items in inventory
        return this.items;
    }
    fun checkSize(slot: Number) {
        // check if slot is in range
        Assert.assert(slot >= 0 && slot < this.size, "Slot " + slot + " is out of range. ");
    }

    // getSlot(int slot) : Item
    fun getSlot(slot: Number): ItemStack | Null {
        this.checkSize(slot);
        // return item in slot
        return this.items[slot];
    }

    fun getCount(slot : Number) : Number {
        this.checkSize(slot);
        item = this.items[slot];
        if (item == null) {
            return 0;
        }
        return item.getCount();
    }

    fun setSlot(slot: Number, item: ItemStack | Null) {
        this.checkSize(slot);
        Assert.assert(item == null || item.getCount() > 0, " Item count must be greater than 0. ");
        // set item in slot
        this.removeSlot(slot);
        // if item is not null
        if (item != null) {
            // add item to slot
            this.addSlot(slot, item);
        }
    }
    fun setSize(size: Number) {
        // set size of inventory
        this.size = size;
        copyList = this.items.copy();
        // copy items, and fill the rest with nulls with for loop
        for (i = 0; i < size; i++) {
            if (i < len(copyList)) {
                this.items[i] = copyList[i];
            }
            else {
                this.items.append(null);
            }
        }
    }
    // accept item and returns null or remainder item
    fun insert(item : ItemStack | Null) : ItemStack | Null {
        Assert.assert(item == null || item.getCount() > 0, " Item count must be greater than 0. ");
        // if item is null, return null
        if (item == null ) {
            return null;
        }
        // check if there is a slot with the same item, by name and nbt first
        for (i = 0; i < this.size; i++) {
            // if slot is not empty and item is the same
            if (this.items[i] != null && ItemUtil.areEqualIncludeNbt(this.items[i], item)) {
                // save item amount
                slotStackSize = this.items[i].getCount();
                // save another item amount
                itemStackSize = item.getCount();
                // Try increment amount.
                // calculate amount that can be added.
                amountToAdd = Math.min(itemStackSize, this.items[i].getMaxStackSize() - slotStackSize);
                // add amount to item
                this.items[i].setStackSize(slotStackSize + amountToAdd);
                // decrement amount from item
                item.setStackSize(itemStackSize - amountToAdd);
                // if item amount is 0, return
                if (item.getCount() == 0) {
                    return null;
                }
            }
            // if slot is empty, add item to slot
            // check if item has valid stack size. if not, try to split it.
            if (this.items[i] == null) {
                // split item if it is too big
                if (item.getCount() > item.getMaxStackSize()) {
                    // copy item by creating new item
                    newItem = new ItemStack(item);
                    // set nbt
                    newItem.setNbt(item.getNbt());
                    // set new item stack size to max stack size
                    newItem.setStackSize(newItem.getMaxStackSize());
                    // decrement item stack size
                    item.setStackSize(item.getCount() - item.getMaxStackSize());
                    // add new item to slot
                    this.addSlot(i, newItem);
                }
                else {
                    // add item to slot
                    this.addSlot(i, item);
                    // return
                    return null;
                }
            }
        }
        // check if remainder item is empty
        if (item.getCount() == 0) {
            // if remainder item is empty, return null
            return null;
        }
        // if remainder item is not empty, return it
        return item;
    }

    fun refresh() {
        // refresh backend map
        this.backEndMap.clear();
        for (i = 0; i < this.size; i++) {
            if (this.items[i] != null) {
                this.backEndMap.add(this.items[i]);
            }
        }
    }

    fun match(stack : ItemStack | Null) : Number {
        // if stack is null, return false
        if (stack == null) {
            return 0;
        }
        // count = 0, accumulator
        count = 0;
        // check if there is a slot with the same item, by name and nbt first
        for (i = 0; i < this.size; i++) {
            // if slot is not empty and item is the same
            if (this.items[i] != null && ItemUtil.areEqualIncludeNbt(this.items[i], stack)) {
                // accumulate count
                count += this.items[i].getCount();
            }
        }
        return count;
    }

    fun match(stack : ItemStack | String, matchNbt : Boolean) : Number {
        // if stack is null, return false
        stack = ItemUtil.of(stack);
        if (matchNbt) {
            return this.match(stack);
        }
        // count = 0, accumulator
        count = 0;
        // check if there is a slot with the same item, by name and nbt first
        for (i = 0; i < this.size; i++) {
            // if slot is not empty and item is the same
            if (this.items[i] != null && ItemUtil.areEqualIgnoreNbt(this.items[i], stack)) {
                // accumulate count
                count += this.items[i].getCount();
            }
        }
        return count;
    }

    fun matchPredicate(predicate : Function) : Number {
        // count = 0, accumulator
        count = 0;
        // check if there is a slot with the same item, by name and nbt first
        for (i = 0; i < this.size; i++) {
            // if slot is not empty and item is the same
            if (this.items[i] != null && predicate(this.items[i])) {
                // accumulate count
                count += this.items[i].getCount();
            }
        }
        return count;
    }

    fun mapSlots(function : Function) : List {
        // maps function for each slot and collects results
        result = [];
        for (i = 0; i < this.size; i++) {
            result.append(function(this.items[i]));
        }
        return result;
    }
    // extracts and returns item that is not fully extracted
    fun takeAll(items : List) : List{
        // items are {itemName : amount}
        returnValue = [];
        foreach (item : items) {
            // extract item from inventory
            extracted = this.extract(item, item.getCount());
            if (extracted < item.getCount()) {
                // add item to return value.
                newItem = ItemUtil.copy(item, item.getCount() - extracted);
                returnValue.append(newItem);
            }
        }
        return returnValue;
    }

    fun takeMap(items : Map) {
        // items are {itemName : amount}
        foreach (item : items.getKey()) {
            // extract item from inventory
            this.extract(ItemStack.of(item), items.get(item));
        }
    }

    // extract item from inventory.
    // match item by name and nbt, then extract amount of items.
    // returns 0 if item was not found, or amount of items extracted.
    fun extract(item : ItemStack| Null, amount : Number) : Number{
        Assert.assert(item == null || item.getCount() > 0, " Item count must be greater than 0. ");
        // if item is null, return 0
        if (item == null) {
            return 0;
        }
        // iterate over items
        extracted = 0;
        for (i = 0; i < this.size; i++) {
            // if slot is not empty and item is the same
            if (this.items[i] != null && ItemUtil.areEqualIncludeNbt(this.items[i], item)) {
                // save item amount
                slotStackSize = this.items[i].getCount();
                // calculate amount that can be extracted.
                amountToExtract = Math.min(amount, slotStackSize);
                // decrement amount from item
                this.items[i].setStackSize(slotStackSize - amountToExtract);
                // increment extracted amount
                extracted += amountToExtract;
                // decrement amount
                amount -= amountToExtract;
                // if item amount is 0, remove item from slot
                if (this.items[i].getCount() == 0) {
                    this.removeSlot(i);
                }
            }
            // after each iteration, check if amount is 0
            if (amount == 0) {
                this.refresh();
                // if amount is 0, return extracted amount
                return extracted;
            }
        }
        this.refresh();
        // return extracted amount
        return extracted;
    }
    // real extraction that also clicks on slots
    fun move(item : ItemStack| Null, amount : Number, storage) : Number{
        // throw Error, indicate that extract(item, amount, storage) should be implemented in child class
        throw new Error("extract(item, amount, storage) should be implemented in child class");
    }

    // this should be private
    fun addSlot(slot: Number, item: ItemStack | Null) {
        Assert.assert(item == null || item.getCount() > 0, " Item count must be greater than 0. ");
        // check if item is null
        if (item == null) {
            // if item is null, remove item from slot
            this.removeSlot(slot);
            return;
        }
        Assert.assert(this.items[slot] == null, "Slot is not empty");
        // add item to slot
        this.items[slot] = item;
        this.backEndMap.add(item);
    }
    // this should be private
    fun removeSlot(slot: Number) {
        // remove item from slot
        this.backEndMap.decrement(this.items[slot]);
        this.items[slot] = null;
    }

    fun increment(slot : Number, amount : Number) : Number {
        // returns incremented amount
        stack = this.getSlot(slot);
        if (stack != null) {
            freeSpace = stack.getMaxCount() - stack.getCount();
            amount = Math.min(amount, freeSpace);
            stack.setStackSize(stack.getCount() + amount);
        }
        else {
            return 0;
        }
        this.backEndMap.increment(stack, amount);
        return amount;
    }

    fun decrement(slot : Number, amount : Number) : Number {
        stack = this.getSlot(slot);
        if (stack != null) {
            Assert.assert(stack.getCount() != 0, "Stack was empty");
            // calculate amount that can be extracted.
            amount = Math.min(amount, stack.getCount());
            stack.setStackSize(stack.getCount() - amount);
            Logger.debug("decremented " + amount + " items from slot " + slot + "");
        }
        else {
            return 0;
        }
        // if stack size is 0, remove item from slot
        if (stack != null && stack.getCount() == 0) {
            this.removeSlot(slot);
            Logger.debug("removed item from slot " + slot + "");
        }
        return amount;
    }
    fun clone() {
        // throw Error, indicate that clone() should be implemented in child class
        throw new Error("clone() should be implemented in child class");
    }

    fun toString(){
        return StringUtil.pretty(this.items);
    }
}

class ContainerInventory : AbstractInventory {
    // allowCache flag is used to enable/disable cache.
    // if cache is enabled, it will store inventories in cache. Also we can directly access inventories from cache.
    static var allowCache = false;
    // we may store found inventories in cache, but cache is only called if allowCache is true.
    // static var CACHE : Map -> {(world, pos) -> ContainerInventory}
    static var CACHE = {};

    // constructor
    ContainerInventory(size: Number) : super(size) {
        // nothing to do here
    }

    // static method of constructs from existing item.
    // if item is ContainerInventory, return it.
    // else throw error.
    // example code:
    // inventory = ContainerInventory.of(item);


    static fun of(item: ItemStack) : ContainerInventory {
        // if item is ContainerInventory, return it.
        if (ContainerInventory.isInventoryItem(item)) {
            //create new inventory
            // usually size is hardcoded as 27, but it can be changed.
            inventory = new ContainerInventory(27);
            // iterate over items in nbt
            // list is [{id : name, Slot : integer, tag? : map},...] form.
            for (i = 0; i < len(item.getNbt().get("BlockEntityTag").get("Items")); i++) {
                // get item
                itemInNbt = item.getNbt().get("BlockEntityTag").get("Items")[i];
                // create new item
                // if tag is null, skip
                // we use id, count, tag to create item
                newItem = null;
                if (itemInNbt.get("tag") != null) {
                    newItem = ItemStack.of(itemInNbt.get("id"));
                    // modify tag and count
                    newItem.setNbt(itemInNbt.get("tag"));
                }
                else {
                    newItem = ItemStack.of(itemInNbt.get("id"));
                }
                // assert count is greater than 0
                Assert.assert(itemInNbt.get("Count") > 0, "Item count must be greater than 0");
                // set stack size
                newItem.setStackSize(itemInNbt.get("Count"));
                // add item to inventory
                inventory.addSlot(itemInNbt.get("Slot"), newItem);
            }
            // return inventory
            return inventory;
        }
        // else throw error.
        else {
            throw new Error("Cannot construct ContainerInventory from item " + item);
        }
    }

    // private (but currently private is not implemented)
    // isInventoryItem(item: ItemStack) : Boolean , returns true if item is inventory item
    static fun isInventoryItem(item: ItemStack) : Boolean {
        // check if item has inventory tag
        // access nbt by BlockEntityTag then Items
        // returns true if item has non-empty list of items
        return item.getNbt().get("BlockEntityTag").get("Items").size() > 0;
    }

    // static method of constructs from existing block.
    // if block is container, return inventory.
    // else throw error.
    // example code:
    // inventory = ContainerInventory.ofBlock(pos, world);
    static fun ofBlock(args...) : ContainerInventory {
        // lets use varargs
        arguments = new VarArgs(args);
        // get position
        pos = arguments.get(0, Pos.type);
        // get world
        world = arguments.getOrDefault(1, Player.get().getWorld(), World.type);
        // convert world to string
        worldName = world.getFullId();
        // lets check cache first with [world, pos] as key if allowCache is true
        if (ContainerInventory.allowCache) {
            // if cache is present, return it
            if (ContainerInventory.CACHE[[worldName, pos]] != null) {
                return ContainerInventory.CACHE[[worldName, pos]];
            }
        }
        // maybe check closeScreen 
        closeScreen = arguments.getOrDefault(2, false);
        // get block
        block = world.getBlockAt(pos);
        // if block is container, return inventory
        if (block.isBlockEntity()) {
            // construct from screen
            // try get ScreenInventory
            // we get LazyOptional here
            screenInventory = ScreenInventory.construct(pos);
            // check present value of LazyOptional
            // try for RESTRICTION_MAP['max_tries'] times until it is present
            // will throw error if it is not present
            currentValue = null;
            for (i = 0; i < RESTRICTION_MAP['max_tries']; i++) {
                currentValue = screenInventory.get();
                if (currentValue != null) {
                    break;
                }
                // sleep for 100 ms
                sleep(100);
            }
            if (DEBUG_FLAG) {
                Assert.assert(currentValue != null, "Cannot get ScreenInventory from " + pos);
            }
            else {
                if (currentValue == null) {
                    Logger.error("Cannot get ScreenInventory from " + pos);
                    return new ContainerInventory(0);
                }
            }
            // if closeScreen is true, close screen
            if (closeScreen) {
                // close screen
                ScreenInventory.closeScreen();
            }
            // if debug flag is true, assert currentValue is not null, else return empty inventory
            if (DEBUG_FLAG) {
                Assert.assert(currentValue != null, "Cannot get ScreenInventory from " + pos);
            }
            else {
                if (currentValue == null) {
                    Logger.error("Cannot get ScreenInventory from " + pos);
                    return new ContainerInventory(0);
                }
            }
            containerInventory = currentValue; //.toContainerInventory();
            // cache ContainerInventory in CACHE if allowCache is true
            if (ContainerInventory.allowCache) {
                ContainerInventory.CACHE[[worldName, pos]] = containerInventory;
            }
            // return ContainerInventory
            return containerInventory;
        }
        // else throw error
        else {
            if (DEBUG_FLAG) {
                throw new Error("Cannot construct ContainerInventory from block " + pos + " in world " + worldName);
            }
            Logger.error("Cannot construct ContainerInventory from block " + pos + " in world " + worldName);
            // in release mode, return empty inventory
            return new ContainerInventory(0);
        }
    }

    fun loadList(itemList : List) {
        // set size of inventory
        this.setSize(len(itemList));
        // iterate over items
        for (i = 0; i < len(itemList); i++) {
            // assert item is ItemStack or null
            Assert.assert(itemList[i] == null || itemList[i].instanceOf(ItemStack.type), "index [" + i + "] is neither ItemStack nor null");
            // add item to inventory
            this.addSlot(i, itemList[i]);
        }
    }
    
    static fun fromList(itemList : List) {
        // create new inventory
        inventory = new ContainerInventory(len(itemList));
        // iterate over items
        for (i = 0; i < len(itemList); i++) {
            // assert item is ItemStack or null
            Assert.assert(itemList[i] == null || itemList[i].instanceOf(ItemStack.type), "index [" + i + "] is neither ItemStack nor null");
            // add item to inventory
            inventory.addSlot(i, itemList[i]);
        }
        // return inventory
        return inventory;
    }
    // reads from json, which is [{id : name, Slot : integer, tag? : map},...] form.
    static fun fromJson(mapping : List) {
        // create new inventory
        inventory = new ContainerInventory(len(mapping));
        // iterate over items
        for (i = 0; i < len(mapping); i++) {
            // get item
            itemInNbt = mapping[i];
            // if item is null, skip
            if (itemInNbt == null) {
                continue;
            }
            // create new item
            // if tag is null, skip
            // we use id, count, tag to create item
            newItem = null;
            if (itemInNbt.get("tag") != null) {
                newItem = ItemStack.of(itemInNbt.get("id"));
                // modify tag and count
                newItem.setNbt(itemInNbt.get("tag"));
            }
            else {
                newItem = ItemStack.of(itemInNbt.get("id"));
            }
            // assert Count is greater than 0
            Assert.assert(itemInNbt.get("Count") > 0, "Count of item " + itemInNbt.get("id") + " is less than 1");
            // set stack size
            newItem.setStackSize(itemInNbt.get("Count"));
            // add item to inventory
            inventory.setSlot(i, newItem);
        }
        // return inventory
        return inventory;
    }
    // converts to json, which is [{id : name, Slot : integer, tag? : map},...] form.
    fun toJson() {
        // create new list
        mapping = [];
        // iterate over items
        for (i = 0; i < len(this.items); i++) {
            // get item
            item = this.items[i];
            // if item is null, append null
            if (item == null) {
                mapping.append(null);
                continue;
            }
            // create new item
            // if tag is null, skip
            // we use id, count, tag to create item
            itemInNbt = {};
            // set id
            itemInNbt.put("id", item.getFullId());
            // set count
            itemInNbt.put("Count", item.getCount());
            // set tag
            if (item.getNbt() != null) {
                itemInNbt.put("tag", item.getNbt());
            }
            // add item to mapping
            mapping.append(itemInNbt);
        }
        // return mapping
        return mapping;
    }

    fun clone(){
        return new ContainerInventory.fromJson(this.toJson());
    }
}

class CraftingInventory {
    var inputSlots = [];
    var outputSlots = [0];

    CraftingInventory(inputSlots : List, outputSlots : List) {
        this.inputSlots = inputSlots;
        this.outputSlots = outputSlots;
    }
    
    static fun ofCraftingGrid(is3x3Grid : Boolean) {
        // returns dummy inventory of crafting grid.
        // if is3x3Grid is true, input slots is 1-9, output slot is 0
        // else input slots is 1-4, output slot is 0
        // return CraftingInventory
        if (is3x3Grid) {
            return new CraftingInventory([1, 2, 3, 4, 5, 6, 7, 8, 9], [0]);
        }
        else {
            return new CraftingInventory([1, 2, 3, 4], [0]);
        }
    }
}



class ScreenInventory : ContainerInventory {
    // inventory of open screen
    // Container but requires slot number
    // because this class is for actual inventory operations.
    // static var that holds screen names that is for inventory
    static var PLAYER = null; // reference to playet
    static var WHITELISTED_SCREENS = {
        'GenericContainer' : true,
        'ShulkerBox' : true
    };
    static var MAX_TRIES = 10;
    static var WAIT_TIME = 0.05; // 0.3 second
    static var MAX_CPT = 24; // 40 cps = 2 cpt(click per tick)
    static var CHECK_EVERY = 4; // check every 4 ticks
    static var TICK = 4; // 20 ticks per second, decreases by 1 every tick
    static var CLICKED_COUNT = 0; // number of clicks in a second, refreshed every second
    static var CLICK_SLEEP_MS = 100; // sleep 100 ms after click
    var itemList = [];
    var slotNums = []; // saves slot numbers of items
    ScreenInventory() : super(27){
        // call parseScreen
        result = ScreenInventory.parseScreen();
        // if result is not null, we can get the itemList by get()
        if (result != null) {
            this.itemList = result.get().itemList;
            this.slotNums = result.get().slotNums;
        }
        // initialize this.loadList from ContainerInventory
        this.loadList(this.itemList);
    }
    ScreenInventory(items) : super(27) {
        // warn that ScreenInventory was constructed with only items
        Logger.warn("ScreenInventory was constructed with only items. This is not recommended.");
        this.itemList = items;
        this.loadList(this.itemList);
    }
    ScreenInventory(itemList, slotNums) : super(27){
        this.itemList = itemList;
        this.slotNums = slotNums;
        this.loadList(this.itemList);
    }

    static fun wait(){
        // wait for WAIT_TIME seconds
        sleep(ScreenInventory.WAIT_TIME * 1000);
    }

    fun moveFrom(stack, amount) : Number {
        containsAmount = this.match(stack);
        // do nothing
        return Math.min(containsAmount, amount);
    }
    static fun resetClickCount(){
        // reset click count and tick if tick is 0
        if (ScreenInventory.TICK == 0) {
            ScreenInventory.TICK = ScreenInventory.CHECK_EVERY;
            ScreenInventory.CLICKED_COUNT = 0;
        }
    }

    static fun cpsRestriction(){
        ScreenInventory.CLICKED_COUNT++;
        // if cps is over max cps, wait for 0.05 seconds by sleep(50)
        if (ScreenInventory.CLICKED_COUNT >= ScreenInventory.MAX_CPT * ScreenInventory.CHECK_EVERY) {
            sleep(ScreenInventory.CLICK_SLEEP_MS);
        }
    }

    static fun getCurrentScreenName() : String | Null {
        // get player
        player = Player.get();
        // get current screen
        screen = player.getCurrentScreen();
        // if screen is null, return null
        if (screen == null) {
            return null;
        }
        // else return screen name
        return screen.getName();
    }

    static fun isPlayerInventoryScreen(): Boolean {
        // get current screen name
        screenName = ScreenInventory.getCurrentScreenName();
        // if screenName is null, return false
        if (screenName == null) {
            return false;
        }
        return screenName == 'Inventory' || screenName == 'CreativeInventory';
    }

    // from player open screen, construct ScreenInventory
    static fun hasOpenScreen(){
        // get player open screen
        player = Player.get();
        screen = player.getCurrentScreen();
        // if screen is not null
        if (screen != null) {
            return true;
        }
        // else return null
        else {
            return false;
        }
    }

    // fun getItemMap() -> returns {slotNum : item} instead of [item, item, ...] using slotNums
    fun getItemMap() {
        // create new map
        map = {};
        // iterate over items
        for (i = 0; i < len(this.items); i++) {
            // get item
            item = this.items[i];
            // if item is null, skip
            if (item == null) {
                continue;
            }
            // add item to map
            map.put(this.slotNums[i], item);
        }
        // return map
        return map;
    }

    // exclusively construct from player slots. exclude armor, offhand, crafting slots
    static fun ofPlayerInventory() { // LazyOptional<ScreenInventory>
        // get player open screen
        player = Player.get();
        screen = player.getCurrentScreen();
        // if screen is not null
        if (screen != null) {
            itemList = [];
            slotNums = [];
            // get inventory size
            size = player.getTotalSlots();
            // iterate over inventory
            for (i = 0; i < size; i++) {
                // get item
                item = player.getItemForSlot(i);
                item = ItemUtil.copy(item); // we need to copy item because item is reference
                // debug
                // if item is null, reference null to item
                if (item == null || item.getCount() == 0) {
                    item = null;
                }
                // if current screen name is Inventory and i is 45, skip
                if (ScreenInventory.isPlayerInventoryScreen() && i == 45) {
                    continue;
                }
                // if item is not null and slot is not player slot
                if (player.isPlayerSlot(i)) {
                    // add item to inventory
                    itemList.append(item);
                    // add slot number to slotNums
                    slotNums.append(i);
                }
            }
            // assert that itemList and slotNums are same length
            Assert.assert(len(itemList) == len(slotNums), "itemList and slotNums are not same length");
            // wrap with LazyOptional
            return new LazyOptional(new ScreenInventory(itemList, slotNums));
        }
        // else return null
        else {
            // there is no current screen.
            // we need to exclude armor, offhand, crafting slots which is 0~8
            // then just iterate 
            size = player.getTotalSlots();
            itemList = [];
            slotNums = [];
            for (i = 0; i < size; i++) {
                // jump to 9
                if (i < 9) {
                    continue;
                }
                // get item
                item = player.getItemForSlot(i);
                item = ItemUtil.copy(item); // we need to copy item because item is reference
                // debug
                // if item is null, reference null to item
                if (item == null || item.getCount() == 0) {
                    item = null;
                }
                if (i == 45) {
                    continue;
                }
                // if item is not null and slot is not player slot
                if (player.isPlayerSlot(i)) {
                    // add item to inventory
                    itemList.append(item);
                    // add slot number to slotNums
                    slotNums.append(i);
                }
            }
            // wrap with LazyOptional
            return new LazyOptional(new ScreenInventory(itemList, slotNums));
        }
    }

    static fun parseScreen(){ // : LazyOptional<ScreenInventory>
        // get player open screen
        player = Player.get();
        screen = player.getCurrentScreen();
        // if screen is not null
        if (screen != null) {
            // get screen name
            screenName = screen.getName();
            itemList = [];
            slotNums = [];
            // get inventory size
            size = player.getTotalSlots();
            // iterate over inventory
            for (i = 0; i < size; i++) {
                // if screen is Crafting Screen, skip 0
                if (screenName == 'Crafting' && i == 0) {
                    continue;
                }
                // get item
                item = player.getItemForSlot(i);
                item = ItemUtil.copy(item); // we need to copy item because item is reference
                // debug
                // if item is null, reference null to item
                if (item == null || item.getCount() == 0) {
                    item = null;
                }
                // if item is not null and slot is not player slot
                if (!player.isPlayerSlot(i)) {
                    // add item to inventory
                    itemList.append(item);
                    // add slot number to slotNums
                    slotNums.append(i);
                }
            }
            // wrap with LazyOptional and return
            return new LazyOptional(new ScreenInventory(itemList, slotNums));
        }
        // else return null
        else {
            return null;
        }
    }
    // static function that closes any open screen then wait
    static fun closeScreen(){
        player = Player.get();
        // try 10 times
        for (i = 0; i < ScreenInventory.MAX_TRIES; i++) {
            // if screen is null, break
            player.closeScreen();
            sleep(ScreenInventory.WAIT_TIME * 1000);
            if (player.getCurrentScreen() == null) {
                break;
            }
            // else sleep
        }
        // wait for screen to close
    }

    // constructs from screen. First close screen, then try interact with block.
    static fun construct(pos) {
        ScreenInventory.closeScreen(); // close screen first.
        // open screen first.
        canOpen = ScreenInventory.openScreen(pos);
        if (canOpen) {
            // try to parse screen
            // store value then check and return
            value = ScreenInventory.parseScreen();
            if (value != null) {
                return value;
            }
            // else throw error
            else {
                throw new Error("Cannot construct ScreenInventory from screen for pos " + pos);
            }
        }
        return new LazyOptional(fun(){return ScreenInventory.construct(pos).get();}, fun (){return ScreenInventory.canInteractBlock(pos);});
    }
    // constructs ContainerInventory from ScreenInventory
    fun toContainerInventory(){
        return ContainerInventory.fromList(this.itemList);
    }

    fun clone(){
        // clone itemList, using ItemUtil.copy for each item
        itemList = [];
        foreach (item : this.itemList) {
            itemList.append(ItemUtil.copy(item));
        }
        // clone slotNums using list.copy
        slotNums = this.slotNums.copy();
        // return new ScreenInventory
        return new ScreenInventory(itemList, slotNums);
    }

    static fun canInteractBlock(pos : Pos){
        player = Player.get();
        return !ScreenInventory.hasOpenScreen() && player.getPos().distanceTo(pos) <= RESTRICTION_MAP["reach_distance"] ;
    }

    static fun openScreen(pos : Pos) {
        player = Player.get();
        player.closeScreen();
        // if player can interact with block
        if (ScreenInventory.canInteractBlock(pos)) {
            // try for MAX_TRIES times to open screen
            for (i = 0; i < ScreenInventory.MAX_TRIES; i++) {
                player.interactBlock(pos, 'up');
                // if screen is not null, break
                if (ScreenInventory.hasOpenScreen()) {
                    break;
                }
                // else sleep
                sleep(ScreenInventory.WAIT_TIME * 1000);
            }
            sleep(ScreenInventory.WAIT_TIME * 1000);
            return ScreenInventory.hasOpenScreen();
        }
        return false;
    }

    // initialize ScreenInventory.PLAYER
    static fun getPlayer(){
        // if player is not null then just return
        if (ScreenInventory.PLAYER != null) {
            return ScreenInventory.PLAYER;
        }
        // refresh player
        ScreenInventory.PLAYER = Player.get();
        return ScreenInventory.PLAYER;
    }

    static fun refreshPlayer(){
        ScreenInventory.PLAYER = Player.get();
    }

    // right clicks slot once
    // player.clickSlot(slotNum, click, action) : void
    // action : 'click', 'shift_click', 'swap', 'middle_click', 'throw', 'drag', or 'double_click'
    static fun rightClickSlot(slot : Number) {
        ScreenInventory.clickSlot(slot, 'right', 'click');
        ScreenInventory.cpsRestriction();
    }

    // left clicks slot once
    static fun leftClickSlot(slot : Number) {
        ScreenInventory.clickSlot(slot, 'left', 'click');
        ScreenInventory.cpsRestriction();
    }

    // shift clicks slot once
    static fun shiftClickSlot(slot : Number) {
        // Debug
        ScreenInventory.clickSlot(slot, 'left', 'shift_click');
        ScreenInventory.cpsRestriction();
    }

    // throw item from slot
    static fun throwItem(slot : Number) {
        // Debug
        Logger.debug("Throwing item from slot " + slot);
        ScreenInventory.getPlayer().clickSlot(slot, 'left', 'throw');
        ScreenInventory.cpsRestriction();
    }

    // abstract click slot function, get Player and call clickSlot
    static fun clickSlot(slot : Number, click : String, action : String) {
        // Debug
        Logger.debug("Clicking slot " + slot + " with " + click + " click and " + action + " action");
        ScreenInventory.getPlayer().clickSlot(slot, click, action);
        ScreenInventory.cpsRestriction();
    }

    // returns [slotNum, count] that can be inserted into, or null if no slot can be inserted into
    fun findInsertableSlot(item : ItemStack | Null, amount : Number) : List | Null {
        // if item is null, return null and warn
        if (item == null || item.getCount() == 0 || amount == 0) {
            Logger.warn("Cannot find insertable slot for null item");
            return null;
        }
        // iterate over items
        for (i = 0; i < this.size; i++) {
            // if slot is empty or item is the same
            if (this.items[i] == null || ItemUtil.areEqualIncludeNbt(this.items[i], item)) {
                // calculate max insertable amount 
                // if slot is empty, max insertable is item max Stack size
                maxInsertable = null;
                if (this.items[i] == null) {
                    maxInsertable = item.getMaxCount();
                }
                // else max insertable is maxCount - currentCount
                else {
                    maxInsertable = item.getMaxCount() - this.items[i].getCount();
                }
                // if max insertable is greater than amount, return [slotNum, amount]
                if (maxInsertable >= amount) {
                    return [this.slotNums[i], amount];
                }
                // else return [slotNum, maxInsertable]
                else if (maxInsertable > 0) {
                    return [this.slotNums[i], maxInsertable];
                }
            }
        }
        // else return null
        return null;
    }
    // we set slot for screen, but with real slot number instead of index.
    // this is 'accepting' side function.
    fun moveStack(item : ItemStack | Null, amount : Number, screenIndex : Number) {
        // find index that matches screenIndex from slotNums
        index = this.slotNums.indexOf(screenIndex);
        // if index is not -1
        if (index != -1) {
            // create new Item with amount
            newItem = ItemUtil.copy(item, amount);
            // create new item by merging stacks.
            // get existing stack first
            existingStack = this.items[index];
            newItem = ItemUtil.mergeStacks(newItem, existingStack);
            this.setSlot(index, newItem);
            return;
        }
        // else throw error
        else {
            throw new Error("Cannot set slot for screen. Screen index " + screenIndex + " is not found in slotNums");
        }
    }

    static fun migrateStack(slotFrom : Number, slotTo : Number) {
        // debug
        Logger.debug("Migrating items from " + slotFrom + " to " + slotTo);
        // we will click slots.
        // first we left click slotFrom, then we left click slotTo. this will move all items from slotFrom to slotTo.
        ScreenInventory.leftClickSlot(slotFrom);
        ScreenInventory.leftClickSlot(slotTo);
    }

    static fun moveSlot(slotFrom : Number, slotTo: Number, amount : Number) {
        // debug
        Logger.debug("Moving " + amount + " items from " + slotFrom + " to " + slotTo);
        // we will click slots.
        // first we left click slotFrom, then we right click slotTo for amount times.
        ScreenInventory.leftClickSlot(slotFrom);
        for (i = 0; i < amount; i++) {
            ScreenInventory.rightClickSlot(slotTo);
        }
        // finally we left click slotFrom again to put items back.
        ScreenInventory.leftClickSlot(slotFrom);
    }
    // search for stack, get slot number. then move stack to slot.
    // if amount is not enough, redo search.
    // we assume external slot is always empty.
    fun moveStackToExternalSlot(item : ItemStack | Null, amount : Number, slot : Number) : Number{
        // iterate over items
        if (item == null || item.getCount() == 0 || amount == 0) {
            Logger.warn("Cannot move null item");
            return 0;
        }
        moved = 0;
        //if amount is bigger than item max stack size, set amount to item max stack size.
        if (amount > item.getMaxCount()) {
            amount = item.getMaxCount();
        }
        Logger.debug("Moving " + amount + " items to external slot " + slot);
        //assert we have len(items) == len(slotNums) == size
        //Assert.assert(len(this.items) == len(this.slotNums) && len(this.slotNums) == this.size, "items, slotNums and size must be same length but found " + len(this.items) + ", " + len(this.slotNums) + " and " + this.size);
        for (i = 0; i < this.size; i++) {
            // if slot is not empty and item is the same
            if (this.getSlot(i) != null && ItemUtil.areEqualIncludeNbt(item, this.getSlot(i))) {
                // save item amount
                slotStackSize = this.getCount(i);
                // calculate amount that can be extracted.
                amountToExtract = Math.min(amount, slotStackSize);
                // debug slotStackSize and amountToExtract
                Logger.debug("Slot " + this.slotNums[i] + " has " + slotStackSize + " items, extracting " + amountToExtract);
                // move stack to slot by clicking, use migrateStack if we need to move all items.
                if (amountToExtract == slotStackSize) {
                    ScreenInventory.migrateStack(this.slotNums[i], slot);
                }
                // else move items one by one
                else {
                    ScreenInventory.moveSlot(this.slotNums[i], slot, amountToExtract);
                }
                Logger.debug("Slot " + this.slotNums[i] + " now has " + this.getCount(i) + " items");
                // take items from slot
                this.decrement(i, amountToExtract);
                // debug this.getSlot(i)
                Logger.debug("Slot " + this.slotNums[i] + " now has " + this.getCount(i) + " items");
                // subtract amountToExtract from amount
                amount -= amountToExtract;
                moved += amountToExtract;
                // if amount is 0, return
                if (amount == 0) {
                    Logger.debug("Moved " + moved + " items");
                    return moved;
                }
                // else continue
            }
        }
        // if amount is not 0, return moved
        return moved;
    }

    // moveStackToExternalSlot but with Predicate<ItemStack> instead of ItemStack
    fun movePredicateToExternalSlot(itemPredicate : Function, amount : Number, slot : Number) : Number {
        // iterate over items
        moved = 0;
        //if amount is bigger than item max stack size, set amount to item max stack size.
        if (amount > item.getMaxCount()) {
            amount = item.getMaxCount();
        }
        for (i = 0; i < this.size; i++) {
            // if slot is not empty and item is the same
            if (this.items[i] != null && itemPredicate(this.items[i])) {
                // save item amount
                slotStackSize = this.items[i].getCount();
                // calculate amount that can be extracted.
                amountToExtract = Math.min(amount, slotStackSize);
                // move stack to slot by clicking, use migrateStack if we need to move all items.
                if (amountToExtract == slotStackSize) {
                    ScreenInventory.migrateStack(this.slotNums[i], slot);
                }
                // else move items one by one
                else {
                    ScreenInventory.moveSlot(this.slotNums[i], slot, amountToExtract);
                }
                // subtract amountToExtract from amount
                amount -= amountToExtract;
                moved += amountToExtract;
                // if amount is 0, return
                if (amount == 0) {
                    return moved;
                }
                // else continue
            }
        }
        // if amount is not 0, return moved
        return moved;
    }


    // here we implement move(item, count, storage) that actually moves items.
    // storage must be a ScreenInventory
    fun move(item : ItemStack | Null, amount : Number, storage : ScreenInventory) : Number {
        // types are already asserted.
        // if item is null, return 0
        if (item == null) {
            return 0;
        }
        // debug that we are moving item
        Logger.debug("Moving " + amount + " of " + item.getId());
        // iterate over items
        extracted = 0;
        for (i = 0; i < this.size; i++) {
            // if slot is not empty and item is the same
            if (this.getSlot(i) != null && ItemUtil.areEqualIncludeNbt(item, this.getSlot(i))) {
                // save item amount
                slotStackSize = this.getSlot(i).getCount();
                // calculate amount that can be extracted.
                amountToExtract = Math.min(amount, slotStackSize);
                // debug
                // here we actually click slots.
                slotNum = this.slotNums[i];
                // find insertable slot in storage
                insertTarget = storage.findInsertableSlot(item, amountToExtract); // returns null if not found, or [slot, amount]
                // debug
                Logger.debug("Found insertable slot " + insertTarget + " for " + amountToExtract + " of " + item.getId());
                // if insert target is not null, call moveSlot(currentSlot, targetSlot, amount) or migrateStack(currentSlot, targetSlot)
                if (insertTarget != null) {
                    // debug 
                    // if amount is equal to amountToExtract, migrate stack
                    if (insertTarget[1] == slotStackSize) {
                        // debug amount, slotNum, insertTarget[0]
                        Logger.debug("Migrating stack from " + slotNum + " to " + insertTarget[0] + " for amount " + insertTarget[1]);
                        ScreenInventory.migrateStack(slotNum, insertTarget[0]);
                    }
                    // else move slot
                    else {
                        // debug amount, slotNum, insertTarget[0], insertTarget[1]
                        Logger.debug("Moving slot from " + slotNum + " to " + insertTarget[0] + " for amount " + insertTarget[1]);
                        ScreenInventory.moveSlot(slotNum, insertTarget[0], insertTarget[1]);
                    }
                    // set slot for storage with moveStack
                    storage.moveStack(item, insertTarget[1], insertTarget[0]);
                }
                // decrement amount from item
                this.getSlot(i).setStackSize(slotStackSize - amountToExtract);
                // increment extracted amount
                extracted += amountToExtract;
                // decrement amount
                amount -= amountToExtract;
                // if item amount is 0, remove item from slot
                if (this.items[i].getCount() == 0) {
                    this.removeSlot(i);
                }
            }
            // after each iteration, check if amount is 0
            if (amount == 0) {
                this.refresh();
                // if amount is 0, return extracted amount
                return extracted;
            }
        }
        this.refresh();
        // return extracted amount
        return extracted;
    }

    // here we implement moveAllMatching(item, storage) that actually moves items.
    // storage must be a ScreenInventory
    fun moveAllMatching(item : ItemStack | Null, storage : ScreenInventory) : Number {
        // types are already asserted.
        // if item is null, return 0
        if (item == null) {
            return 0;
        }
        // iterate over items
        extracted = 0;
        for (i = 0; i < this.size; i++) {
            // if slot is not empty and item is the same
            if (this.getSlot(i)!= null && ItemUtil.areEqualIncludeNbt(item, this.getSlot(i))) {
                // save item amount
                slotStackSize = this.getSlot(i).getCount();
                // here we actually click slots.
                slotNum = this.slotNums[i];
                // find insertable slot in storage
                insertTarget = storage.findInsertableSlot(item, slotStackSize); // returns null if not found, or [slot, amount]
                // if insert target is not null, call moveSlot(currentSlot, targetSlot, amount) or migrateStack(currentSlot, targetSlot)
                if (insertTarget != null) {
                    // if amount is equal to amountToExtract, migrate stack
                    if (insertTarget[1] == slotStackSize) {
                        ScreenInventory.migrateStack(slotNum, insertTarget[0]);
                    }
                    // else move slot
                    else {
                        ScreenInventory.moveSlot(slotNum, insertTarget[0], insertTarget[1]);
                    }
                    // set slot for storage with moveStack
                    storage.moveStack(item, insertTarget[1], insertTarget[0]);
                }
                // decrement amount from item
                this.getSlot(i).setStackSize(slotStackSize - slotStackSize);
                // increment extracted amount
                extracted += slotStackSize;
                // if item amount is 0, remove item from slot
                if (this.getSlot(i).getCount() == 0) {
                    this.removeSlot(i);
                }
            }
        }
        this.refresh();
        // return extracted amount
        return extracted;
    }

    // here we implement movePredicate(predicate, storage) that actually moves items.
    // storage must be a ScreenInventory, predicate must be a function that takes an ItemStack and returns a boolean.
    fun movePredicate(arguments...) : Number {
        // wrap arguments with VarArgs.
        args = new VarArgs(arguments);
        // predicate : Function, storage : ScreenInventory, amount? : Number
        // assert types with VarArgs.get(index, type), optional argument can be obtained with VarArgs.getOrDefault(index, default, type?)
        predicate = args.get(0, Function.type);
        storage = args.get(1, ScreenInventory.type);
        // amount is optional, default is 100000
        amount = args.getOrDefault(2, 100000, Number.type);
        // iterate over items
        extracted = 0;
        for (i = 0; i < this.size; i++) {
            // if slot is not empty and item is the same
            if (this.getSlot(i) != null && predicate(this.getSlot(i))) {
                // save item amount
                slotStackSize = this.getSlot(i).getCount();
                // calculate amount that can be extracted.
                amountToExtract = Math.min(amount, slotStackSize);
                // here we actually click slots.
                slotNum = this.slotNums[i];
                // find insertable slot in storage
                insertTarget = storage.findInsertableSlot(this.getSlot(i), amountToExtract); // returns null if not found, or [slot, amount]
                // if insert target is not null, call moveSlot(currentSlot, targetSlot, amount) or migrateStack(currentSlot, targetSlot)
                if (insertTarget != null) {
                    // if amount is equal to amountToExtract, migrate stack
                    if (insertTarget[1] == amountToExtract) {
                        ScreenInventory.migrateStack(slotNum, insertTarget[0]);
                    }
                    // else move slot
                    else {
                        ScreenInventory.moveSlot(slotNum, insertTarget[0], insertTarget[1]);
                    }
                    // set slot for storage with moveStack
                    storage.moveStack(this.getSlot(i), insertTarget[1], insertTarget[0]);
                }
                // decrement amount from item
                this.getSlot(i).setStackSize(slotStackSize - amountToExtract);
                // increment extracted amount
                extracted += amountToExtract;
                // decrement amount
                amount -= amountToExtract;
                // if item amount is 0, remove item from slot
                if (this.getSlot(i).getCount() == 0) {
                    this.removeSlot(i);
                }
            }
            // after each iteration, check if amount is 0
            if (amount == 0) {
                this.refresh();
                // if amount is 0, return extracted amount
                return extracted;
            }
        }
        this.refresh();
        // return extracted amount
        return extracted;
    }
    // here we implement moveAll(storage) that actually moves items.
    // storage must be a ScreenInventory
    // we can just use Predicate.always_true() that returns true for all items.
    fun moveAll(storage : ScreenInventory) : Number {
        return this.movePredicate(Predicate.always_true(), storage);
    }
}

// class ItemManager -> contains static functions that does not require actual inventory as arguments.
// Inventories are automatically constucted in any form.
class ItemManager {
    static var CLOSE_SCREEN = true; // if true, screen will be closed after each operation.
    // here we try to find ScreenInventory, and move items from it.
    // static functions
    // moveFromPlayer(ItemStack | Null, Number) : Number - moves items from player inventory.
    // moveToPlayer(ItemStack | Null, Number) : Number - moves items to player inventory.
    // the 2 functions will have Predicate version as well.

    static fun terminate(){
        ScreenInventory.wait();
        if (ItemManager.CLOSE_SCREEN) {
            ScreenInventory.closeScreen();
        }
    }
    static fun moveFromPlayer(arguments...) : Number {
        // using VarArgs, we will get item : ItemStack | Null, amount : Number, isChained? : Boolean
        args = new VarArgs(arguments);
        item = args.get(0, ItemStack.type);
        amount = args.get(1, Number.type);
        isChained = args.getOrDefault(2, false, Boolean.type);
        // if item is null, return 0
        if (item == null) {
            return 0;
        }
        // construct player inventory
        playerInventory = ScreenInventory.ofPlayerInventory().get();
        // if player inventory is not null, call moveAllPredicate with predicate that returns true if item is the same.
        if (playerInventory != null) {
            // use move() function to move items.
            // construct other inventory by ScreenInventory.parseScreen()
            otherInventory = ScreenInventory.parseScreen();
            // if otherInventory is not null, call move(item, amount, otherInventory)
            if (otherInventory != null) {
                return playerInventory.move(item, amount, otherInventory);
            }
        }
        // if isChained is true, we will check if CLOSE_SCREEN is true, and close screen.
        if (isChained) {
            ItemManager.terminate();
        }
        // else return 0
        return 0;
    }
    static fun moveFromPlayerPredicate(arguments...) : Number {
        // using VarArgs, we will get predicate : Function, amount : Number, isChained? : Boolean
        args = new VarArgs(arguments);
        predicate = args.get(0, Function.type);
        amount = args.get(1, Number.type);
        isChained = args.getOrDefault(2, false, Boolean.type);
        // if item is null, return 0
        if (item == null) {
            return 0;
        }
        // construct player inventory
        playerInventory = ScreenInventory.ofPlayerInventory().get();
        // if player inventory is not null, call moveAllPredicate with predicate that returns true if item is the same.
        if (playerInventory != null) {
            // use move() function to move items.
            // construct other inventory by ScreenInventory.parseScreen()
            otherInventory = ScreenInventory.parseScreen();
            // if otherInventory is not null, call move(item, amount, otherInventory)
            if (otherInventory != null) {
                return playerInventory.movePredicate(predicate, amount, otherInventory);
            }
        }
        // if isChained is true, we will check if CLOSE_SCREEN is true, and close screen.
        if (isChained) {
            ItemManager.terminate();
        }
        // else return 0
        return 0;
    }
    static fun moveToPlayer(arguments...) : Number {
        // using VarArgs, we will get item : ItemStack | Null, amount : Number, isChained? : Boolean
        args = new VarArgs(arguments);
        item = args.get(0, ItemStack.type);
        amount = args.get(1, Number.type);
        isChained = args.getOrDefault(2, false, Boolean.type);
        // if item is null, return 0
        if (item == null) {
            return 0;
        }
        // construct player inventory
        playerInventory = ScreenInventory.ofPlayerInventory().get();
        // if player inventory is not null, call moveAllPredicate with predicate that returns true if item is the same.
        if (playerInventory != null) {
            // use move() function to move items.
            // construct other inventory by ScreenInventory.parseScreen()
            otherInventory = ScreenInventory.parseScreen();
            // if otherInventory is not null, call move(item, amount, otherInventory)
            if (otherInventory != null) {
                return otherInventory.move(item, amount, playerInventory);
            }
        }
        // if isChained is true, we will check if CLOSE_SCREEN is true, and close screen.
        if (isChained) {
            ItemManager.terminate();
        }
        // else return 0
        return 0;
    }
    static fun moveToPlayerPredicate(arguments...) : Number {
        // using VarArgs, we will get predicate : Function, amount : Number, isChained? : Boolean
        args = new VarArgs(arguments);
        predicate = args.get(0, Function.type);
        amount = args.get(1, Number.type);
        isChained = args.getOrDefault(2, false, Boolean.type);
        // if item is null, return 0
        if (item == null) {
            return 0;
        }
        // construct player inventory
        playerInventory = ScreenInventory.ofPlayerInventory().get();
        // if player inventory is not null, call moveAllPredicate with predicate that returns true if item is the same.
        if (playerInventory != null) {
            // use move() function to move items.
            // construct other inventory by ScreenInventory.parseScreen()
            otherInventory = ScreenInventory.parseScreen();
            // if otherInventory is not null, call move(item, amount, otherInventory)
            if (otherInventory != null) {
                return otherInventory.movePredicate(predicate, amount, playerInventory);
            }
        }
        // if isChained is true, we will check if CLOSE_SCREEN is true, and close screen.
        if (isChained) {
            ItemManager.terminate();
        }
        // else return 0
        return 0;
    }

    // here we first tries to get ScreenInventory by ofBlock(pos) access, then call moveToPlayer and its variants.
    // moveToPos = moves to inventory of pos from player.
    static fun moveToPos(arguments...) : Number {
        // using VarArgs, we will get pos : Pos, item : ItemStack | Null, amount : Number, isChained? : Boolean
        args = new VarArgs(arguments);
        pos = args.get(0, Pos.type);
        item = args.get(1, ItemStack.type);
        amount = args.get(2, Number.type);
        isChained = args.getOrDefault(3, false, Boolean.type);
        // if item is null, return 0
        if (item == null) {
            return 0;
        }
        // construct player inventory
        otherInventory = ContainerInventory.ofBlock(pos);
        playerInventory = ScreenInventory.ofPlayerInventory().get();
        // non-predicate version, moves from player to otherInventory
        if (otherInventory != null && playerInventory != null) {
            return playerInventory.move(item, amount, otherInventory);
        }
        // if isChained is true, we will check if CLOSE_SCREEN is true, and close screen.
        if (isChained) {
            ItemManager.terminate();
        }
        // else return 0
        return 0;
    }
    static fun moveToPosPredicate(arguments...) : Number {
        // using VarArgs, we will get pos : Pos, predicate : Function, amount : Number, isChained? : Boolean
        args = new VarArgs(arguments);
        pos = args.get(0, Pos.type);
        predicate = args.get(1, Function.type);
        amount = args.get(2, Number.type);
        isChained = args.getOrDefault(3, false, Boolean.type);
        // if item is null, return 0
        if (item == null) {
            return 0;
        }
        // construct player inventory
        otherInventory = ContainerInventory.ofBlock(pos);
        playerInventory = ScreenInventory.ofPlayerInventory().get();
        // non-predicate version, moves from player to otherInventory
        if (otherInventory != null && playerInventory != null) {
            return playerInventory.movePredicate(predicate, amount, otherInventory);
        }
        // if isChained is true, we will check if CLOSE_SCREEN is true, and close screen.
        if (isChained) {
            ItemManager.terminate();
        }
        // else return 0
        return 0;
    }
    static fun moveFromPos(arguments...) : Number {
        // using VarArgs, we will get pos : Pos, item : ItemStack | Null, amount : Number, isChained? : Boolean
        args = new VarArgs(arguments);
        pos = args.get(0, Pos.type);
        item = args.get(1, ItemStack.type);
        amount = args.get(2, Number.type);
        isChained = args.getOrDefault(3, false, Boolean.type);
        // if item is null, return 0
        if (item == null) {
            return 0;
        }
        // construct player inventory
        otherInventory = ContainerInventory.ofBlock(pos);
        playerInventory = ScreenInventory.ofPlayerInventory().get();
        // non-predicate version, moves from player to otherInventory
        if (otherInventory != null && playerInventory != null) {
            return otherInventory.move(item, amount, playerInventory);
        }
        // if isChained is true, we will check if CLOSE_SCREEN is true, and close screen.
        if (isChained) {
            ItemManager.terminate();
        }
        // else return 0
        return 0;
    }
    static fun moveFromPosPredicate(arguments...) : Number {
        // using VarArgs, we will get pos : Pos, predicate : Function, amount : Number, isChained? : Boolean
        args = new VarArgs(arguments);
        pos = args.get(0, Pos.type);
        predicate = args.get(1, Function.type);
        amount = args.get(2, Number.type);
        isChained = args.getOrDefault(3, false, Boolean.type);
        // if item is null, return 0
        if (item == null) {
            return 0;
        }
        // construct player inventory
        otherInventory = ContainerInventory.ofBlock(pos);
        playerInventory = ScreenInventory.ofPlayerInventory().get();
        // non-predicate version, moves from player to otherInventory
        if (otherInventory != null && playerInventory != null) {
            return otherInventory.movePredicate(predicate, amount, playerInventory);
        }
        // if isChained is true, we will check if CLOSE_SCREEN is true, and close screen.
        if (isChained) {
            ItemManager.terminate();
        }
        // else return 0
        return 0;
    }
    // Area version of move functions. We tries to get nearby inventories list. Then we call move functions until condition is met.
    static fun moveToNearby(stack : ItemStack | Null, amount : Number) :Number {
        nearbyInventories = getNearbyInventory(RESTRICTION_MAP['reach_distance']);
        moved = 0;
        // this is [pos, ...]
        foreach (nearbyInventoryPos : nearbyInventories) {
            // if item is null, return 0
            if (stack == null) {
                return 0;
            }
            // construct player inventory
            otherInventory = ContainerInventory.ofBlock(nearbyInventoryPos);
            playerInventory = ScreenInventory.ofPlayerInventory().get();
            // non-predicate version, moves from player to otherInventory
            if (otherInventory != null && playerInventory != null) {
                moved += playerInventory.move(stack, amount, otherInventory);
            }
            // check if player has enough items
            if (playerInventory.match(stack) == 0) {
                ItemManager.terminate();
                return moved;
            }
            // check if moved is enough
            if (moved >= amount) {
                ItemManager.terminate();
                return moved;
            }
        }
        ItemManager.terminate();
        // return moved amount
        return moved;
    }

    // Area version of move functions. We tries to get nearby inventories list. Then we call move functions until condition is met.
    static fun moveToNearbyPredicate(predicate : Function, amount : Number) :Number {
        nearbyInventories = getNearbyInventory(RESTRICTION_MAP['reach_distance']);
        moved = 0;
        // this is [pos, ...]
        foreach (nearbyInventoryPos : nearbyInventories) {
            // if item is null, return 0
            if (stack == null) {
                return 0;
            }
            // construct player inventory
            otherInventory = ContainerInventory.ofBlock(nearbyInventoryPos);
            playerInventory = ScreenInventory.ofPlayerInventory().get();
            // non-predicate version, moves from player to otherInventory
            if (otherInventory != null && playerInventory != null) {
                moved += playerInventory.movePredicate(predicate, amount, otherInventory);
            }
            // check if player has enough items
            if (playerInventory.matchPredicate(predicate) == 0) {
                ItemManager.terminate();
                return moved;
            }
            // check if moved is enough
            if (moved >= amount) {
                ItemManager.terminate();
                return moved;
            }
        }
        ItemManager.terminate();
        // return moved amount
        return moved;
    }

    // Area version of move functions. We tries to get nearby inventories list. Then we call move functions until condition is met.
    static fun moveFromNearby(stack : ItemStack | Null, amount : Number) :Number {
        nearbyInventories = getNearbyInventory(RESTRICTION_MAP['reach_distance']);
        moved = 0;
        // this is [pos, ...]
        foreach (nearbyInventoryPos : nearbyInventories) {
            // if item is null, return 0
            if (stack == null) {
                return 0;
            }
            // construct player inventory
            otherInventory = ContainerInventory.ofBlock(nearbyInventoryPos);
            playerInventory = ScreenInventory.ofPlayerInventory().get();
            // non-predicate version, moves from player to otherInventory
            if (otherInventory != null && playerInventory != null) {
                moved += otherInventory.move(stack, amount, playerInventory);
            }
            // check if moved is enough
            if (moved >= amount) {
                ItemManager.terminate();
                return moved;
            }
        }
        ItemManager.terminate();
        // return moved amount
        return moved;
    }

    // Area version of move functions. We tries to get nearby inventories list. Then we call move functions until condition is met.
    static fun moveFromNearbyPredicate(predicate : Function, amount : Number) :Number {
        nearbyInventories = getNearbyInventory(RESTRICTION_MAP['reach_distance']);
        moved = 0;
        // this is [pos, ...]
        foreach (nearbyInventoryPos : nearbyInventories) {
            // if item is null, return 0
            if (stack == null) {
                return 0;
            }
            // construct player inventory
            otherInventory = ContainerInventory.ofBlock(nearbyInventoryPos);
            playerInventory = ScreenInventory.ofPlayerInventory().get();
            // non-predicate version, moves from player to otherInventory
            if (otherInventory != null && playerInventory != null) {
                moved += otherInventory.movePredicate(predicate, amount - moved, playerInventory);
            }
            // check if moved is enough
            if (moved >= amount) {
                ItemManager.terminate();
                return moved;
            }
        }
        ItemManager.terminate();
        // return moved amount
        return moved;
    }
}

class MergedInventory : MatchableInventory {
    // this is a mapped inventories by {world : {pos : inventory}} structure.
    // ultimately we provide moveFrom, moveTo, moveFromPredicate, moveToPredicate functions that moves items from/to inventories.
    var inventories = {};
    MergedInventory() {

    }
    MergedInventory(inventories : Map) {
        this.inventories = inventories;
    }

    static fun ofPositions(positions : Iterable | Null) {
        mergedInventory = new MergedInventory();
        world = Player.get().getWorld();
        if (positions == null) positions = [];
        foreach (pos : positions) {
            mergedInventory.addInventory(world, pos, ContainerInventory.ofBlock(pos));
        }
        ScreenInventory.closeScreen();
        return mergedInventory;
    }

    static fun ofNearby() {
        return MergedInventory.ofPositions(getNearbyInventory(RESTRICTION_MAP["reach_distance"]));
    }

    fun toString(){
        return StringUtil.pretty(this.inventories);
    }

    fun match(itemStack: ItemStack): Number {
        // for each inventories, match it.
        total = 0;
        foreach (world : this.inventories) {
            foreach (pos : this.inventories[world]) {
                total += this.inventories[world][pos].match(itemStack);
            }
        }
        return total;
    }

    fun match(itemStack: ItemStack, matchNbt : Boolean): Number {
        // for each inventories, match it.
        total = 0;
        foreach (world : this.inventories) {
            foreach (pos : this.inventories[world]) {
                total += this.inventories[world][pos].match(itemStack, matchNbt);
            }
        }
        return total;
    }
    fun takeAll(items : List) : List {
        items = items.copy();
        // for each inventories, call takeAll, if result is not empty, then call again.
        // take from player inventory first.
        playerInventory = this.getPlayerInventory();
        if (playerInventory != null) {
            items = playerInventory.takeAll(items);
        }
        foreach (world : this.inventories) {
            if (world == "PLAYER") continue;
            foreach (pos : this.inventories[world]) {
                items = this.inventories[world][pos].takeAll(items);
            }
        }
        return items;
    }

    fun extract(stack : ItemStack, amount : Number) : Number {
        // for each inventories, call extract, if result is not empty, then call again.
        extracted = 0;
        // take from player inventory first.
        playerInventory = this.getPlayerInventory();
        if (playerInventory != null) {
            extracted += playerInventory.extract(stack, amount - extracted);
        }
        foreach (world : this.inventories) {
            if (world == "PLAYER") continue;
            foreach (pos : this.inventories[world]) {
                extracted += this.inventories[world][pos].extract(stack, amount - extracted);
            }
        }
        return extracted;
    }

    fun matchPredicate(predicate: Function): Number {
        // for each inventories, match it.
        total = 0;
        foreach (world : this.inventories) {
            foreach (pos : this.inventories[world]) {
                total += this.inventories[world][pos].matchPredicate(predicate);
            }
        }
        return total;
    }
    fun getItems() : List {
        items = [];
        foreach (world : this.inventories) {
            foreach (pos : this.inventories[world]) {
                items.addAll(this.inventories[world][pos].getItems());
            }
        }
        return items;
    }
    fun clone() {
        // for each inventories, clone it.
        clonedInventories = {};
        foreach (world : this.inventories) {
            clonedInventories[world] = {};
            foreach (pos : this.inventories[world]) {
                clonedInventories[world][pos] = this.inventories[world][pos].clone();
            }
        }
        return new MergedInventory(clonedInventories);
    }

    fun addPlayerInventory(){
        this.inventories["PLAYER"] = {
            "PLAYER" : ScreenInventory.ofPlayerInventory().get()
        };
    }

    fun getPlayerInventory(){
        if (this.inventories["PLAYER"] == null) {
            return null;
        }
        return this.inventories["PLAYER"]["PLAYER"];
    }

    static fun canInteractBlock(pos : Pos) {
        return Player.get().getPos().distanceTo(pos) <= RESTRICTION_MAP["reach_distance"];
    }

    fun addInventory(pos : Pos) {
        this.addInventory(Player.get().getWorld(), pos, ContainerInventory.ofBlock(pos));
        // terminate
        ItemManager.terminate();
    }
    
    fun addInventory(world : World, pos : Pos, inventory : ScreenInventory) {
        world = world.getFullId();
        if (this.inventories[world] == null) {
            this.inventories[world] = {};
        }
        this.inventories[world][pos] = inventory;
    }

    fun removeInventory(world : World, pos : Pos) {
        world = world.getFullId();
        if (this.inventories[world] != null) {
            this.inventories[world].remove(pos);
        }
    }
    

    // by accessing ScreenInventory, we know where to click when screen is opened.
    // returns moved amount.
    fun moveFrom(stack : ItemStack | Null, amount : Number) :Number {
        moved = 0;
        // if item is null, return 0
        if (stack == null) {
            return 0;
        }
        playerInv = this.getPlayerInventory();
        if (playerInv != null) {
            // move from player inventory first. match items, if items are already enough in player inventory, then return amount.
            // else if items are not enough, then subtract and move items from other inventories.
            playerAmount = playerInv.match(stack);
            if (playerAmount >= amount) {
                return amount;
            }
            else {
                moved += playerAmount;
            }
        }
        // this is [pos, ...]
        foreach (world : this.inventories.getKeys()) {
            // if world is different from player's world, skip
            if (world != Player.get().getWorld().getFullId()) {
                continue;
            }
            foreach (pos : this.inventories[world].getKeys()) {
                // if pos = "PLAYER", we can't move from player inventory.
                if (pos == "PLAYER") {
                    continue;
                }
                // if we can't interact with block, skip
                if (!MergedInventory.canInteractBlock(pos)) {
                    Logger.warn("can't interact with block at " + pos);
                    continue;
                }
                // use saved inventory as cache, to find items.
                inventory = this.inventories[world][pos];
                containedAmount = inventory.match(stack); // predicate version is matchPredicate(func)
                // if inventory doesn't contain item, skip
                if (containedAmount == 0) {
                    continue;
                }
                // construct player inventory
                otherInventory = ContainerInventory.ofBlock(pos);
                // rebind inventory to this.inventories[world][pos]
                this.inventories[world][pos] = otherInventory;
                playerInventory = ScreenInventory.ofPlayerInventory().get();
                // non-predicate version, moves from player to otherInventory
                if (otherInventory != null && playerInventory != null) {
                    moved += otherInventory.move(stack, amount - moved, playerInventory);
                }
                // check if moved is enough
                if (moved >= amount) {
                    ItemManager.terminate();
                    return moved;
                }
            }
        }
        ItemManager.terminate();
        // return moved amount
        return moved;
    }
    // moveTo moves items from player inventory to other inventories until item is moved enough.
    fun moveTo(stack : ItemStack | Null, amount : Number) :Number {
        moved = 0;
        // if item is null, return 0
        if (stack == null) {
            return 0;
        }
        // this is [pos, ...]
        // define lambda that returns 64 if item is null, otherwise returns item.getMaxCount() - item.getCount() for given stack.
        lambda = fun (item : ItemStack | Null) :Number {
            if (item == null) {
                return 64;
            }
            return item.getMaxCount() - item.getCount();
        };
        foreach (world : this.inventories.getKeys()) {
            foreach (pos : this.inventories[world].getKeys()) {
                // if pos = "PLAYER", we can't move from player inventory.
                if (pos == "PLAYER") {
                    continue;
                }
                if (world != Player.get().getWorld().getFullId()) {
                    continue;
                }
                // if we can't interact with block, skip
                if (!MergedInventory.canInteractBlock(pos)) {
                    continue;
                }
                // use saved inventory as cache, to find items.
                inventory = this.inventories[world][pos];
                // we calculates free space in inventory for given stack.
                containedAmount = inventory.mapSlots(lambda).reduce(fun(a, b) {return a + b;});
                // if inventory doesn't contain item, skip
                if (containedAmount == 0) {
                    continue;
                }
                // construct player inventory
                otherInventory = ContainerInventory.ofBlock(pos);
                this.inventories[world][pos] = otherInventory;
                playerInventory = ScreenInventory.ofPlayerInventory().get();
                // non-predicate version, moves from player to otherInventory
                if (otherInventory != null && playerInventory != null) {
                    moved += playerInventory.move(stack, amount - moved, otherInventory);
                }
                // check if moved is enough
                if (moved >= amount) {
                    ItemManager.terminate();
                    return moved;
                }
            }
        }
        ItemManager.terminate();
        // return moved amount
        return moved;
    }

    // predicate versions.
    fun moveFromPredicate(predicate : Function, amount : Number) :Number {
        moved = 0;
        // this is [pos, ...]
        foreach (world : this.inventories.getKeys()) {
            foreach (pos : this.inventories[world].getKeys()) {
                // if pos = "PLAYER", we can't move from player inventory.
                if (pos == "PLAYER") {
                    continue;
                }
                if (world != Player.get().getWorld().getFullId()) {
                    continue;
                }
                // if we can't interact with block, skip
                if (!MergedInventory.canInteractBlock(pos)) {
                    continue;
                }
                // use saved inventory as cache, to find items.
                inventory = this.inventories[world][pos];
                // we calculates free space in inventory for given stack.
                containedAmount = inventory.matchPredicate(predicate);
                // if inventory doesn't contain item, skip
                if (containedAmount == 0) {
                    continue;
                }
                // construct player inventory
                otherInventory = ContainerInventory.ofBlock(pos);
                this.inventories[world][pos] = otherInventory;
                playerInventory = ScreenInventory.ofPlayerInventory().get();
                // non-predicate version, moves from player to otherInventory
                if (otherInventory != null && playerInventory != null) {
                    moved += otherInventory.movePredicate(predicate, amount - moved, playerInventory);
                }
                // check if moved is enough
                if (moved >= amount) {
                    ItemManager.terminate();
                    return moved;
                }
            }
        }
        ItemManager.terminate();
        // return moved amount
        return moved;
    }

    fun moveToPredicate(predicate : Function, amount : Number) :Number {
        moved = 0;
        // this is [pos, ...]
        // define lambda that returns 64 if item is null, otherwise returns item.getMaxCount() - item.getCount() for given stack.
        lambda = fun (item : ItemStack | Null) :Number {
            if (item == null) {
                return 64;
            }
            return item.getMaxCount() - item.getCount();
        };
        foreach (world : this.inventories.getKeys()) {
            foreach (pos : this.inventories[world].getKeys()) {
                // if pos = "PLAYER", we can't move from player inventory.
                if (pos == "PLAYER") {
                    continue;
                }
                if (world != Player.get().getWorld().getFullId()) {
                    continue;
                }
                // if we can't interact with block, skip
                if (!MergedInventory.canInteractBlock(pos)) {
                    continue;
                }
                // use saved inventory as cache, to find items.
                inventory = this.inventories[world][pos];
                // we calculates free space in inventory for given stack.
                containedAmount = inventory.mapSlots(lambda).reduce(fun(a, b) {return a + b;});
                // if inventory doesn't contain item, skip
                if (containedAmount == 0) {
                    continue;
                }
                // construct player inventory
                otherInventory = ContainerInventory.ofBlock(pos);
                this.inventories[world][pos] = otherInventory;
                playerInventory = ScreenInventory.ofPlayerInventory().get();
                // non-predicate version, moves from player to otherInventory
                if (otherInventory != null && playerInventory != null) {
                    moved += playerInventory.movePredicate(predicate, amount - moved, otherInventory);
                }
                // check if moved is enough
                if (moved >= amount) {
                    ItemManager.terminate();
                    return moved;
                }
            }
        }
        ItemManager.terminate();
        // return moved amount
        return moved;
    }

    // using inventory.getItems(), we can get all items in merged inventory by iterating over it.
    fun getAllItems() : Map{
        items = {};
        // {world : {pos : inventory}}
        foreach (world : this.inventories.getKeys()) {
            foreach (pos : this.inventories[world].getKeys()) {
                // use saved inventory as cache, to find items.
                inventory = this.inventories[world][pos];
                // register inventory.getItems() into items
                // initiate if world / pos access not exists
                if (items[world] == null) {
                    items[world] = {};
                }
                if (items[world][pos] == null) {
                    items[world][pos] = {};
                }
                items[world][pos] = inventory.getItems();
            }
        }
        return items;
    }
    // check accessible inventories then return them.
    fun getAllAccessibleItems() : Map {
        items = {};
        // {world : {pos : inventory}}
        foreach (world : this.inventories.getKeys()) {
            foreach (pos : this.inventories[world].getKeys()) {
                if (world != Player.get().getWorld().getFullId()) {
                    continue;
                }
                // if we can't interact with block, skip
                if (!MergedInventory.canInteractBlock(pos)) {
                    continue;
                }
                // use saved inventory as cache, to find items.
                inventory = this.inventories[world][pos];
                // register inventory.getItems() into items
                // initiate if world / pos access not exists
                if (items[world] == null) {
                    items[world] = {};
                }
                if (items[world][pos] == null) {
                    items[world][pos] = {};
                }
                // now we can register items
                items[world][pos] = inventory.getItems();
            }
        }
        return items;
    }
}

interface Job {
    // method schedule
    // method cancel
    // method isScheduled
    // method isRunning
    // method isComplete
    // method next
    fun schedule();
    fun cancel();
    fun isScheduled(): Boolean;
    fun isRunning(): Boolean;
    fun isComplete(): Boolean;
    fun next(): Job;
}


class FindItemJob : Job {
    // Find item from storable locations. First from player inventory, then from chests.
    fun schedule();
    fun cancel();
    fun isScheduled(): Boolean;
    fun isRunning(): Boolean;
    fun isComplete(): Boolean;
    fun next(): Job;
}

class SearchRecipesJob : Job {
    // 
    fun schedule();
    fun cancel();
    fun isScheduled(): Boolean;
    fun isRunning(): Boolean;
    fun isComplete(): Boolean;
    fun next(): Job;
}

class AccessCraftingTableJob : Job {
    // method schedule
    // method cancel
    // method isScheduled
    // method isRunning
    // method isComplete
    // method next
    fun schedule();
    fun cancel();
    fun isScheduled(): Boolean;
    fun isRunning(): Boolean;
    fun isComplete(): Boolean;
    fun next(): Job;
}

class CraftItemJob : Job {
    // method schedule
    // method cancel
    // method isScheduled
    // method isRunning
    // method isComplete
    // method next
    fun schedule();
    fun cancel();
    fun isScheduled(): Boolean;
    fun isRunning(): Boolean;
    fun isComplete(): Boolean;
    fun next(): Job;
}

class StoreItemJob : Job {
    // method schedule
    // method cancel
    // method isScheduled
    // method isRunning
    // method isComplete
    // method next
    fun schedule();
    fun cancel();
    fun isScheduled(): Boolean;
    fun isRunning(): Boolean;
    fun isComplete(): Boolean;
    fun next(): Job;
}


// function that searches for item in inventory
// returns [slot number, pos] if found, else null
fun searchItemAnyFromInventory(args...) : List | Null {
    // lets use varargs
    arguments = new VarArgs(args);
    // get inventory
    inventory = arguments.get(0, ContainerInventory.type);
    // get item
    item = arguments.get(1, ItemStack.type);
    // optional pos argument
    pos = arguments.getOrDefault(2, null);
    // iterate over items
    for (i = 0; i < len(inventory.getItems()); i++) {
        // use ItemUtil.areEqualIgnoreNbt(item, founditem) method to compare items, returns true if items are same ignoring nbt.
        // but check if found item is not null
        if (inventory.getItems()[i] != null && ItemUtil.areEqualIgnoreNbt(item, inventory.getItems()[i])) {
            // if found, return 
            return [i, inventory.getItems()[i].getCount(), pos];
        }
    }
    // else return null
    return null;
}

// function that searches all matching item without nbt in inventory
// returns [[slot number, count, pos]...] if found, else null
fun searchAllItemAnyFromInventory(args...) : List | Null {
    // lets use varargs
    arguments = new VarArgs(args);
    // get inventory
    inventory = arguments.get(0, ContainerInventory.type);
    // get item
    item = arguments.get(1, ItemStack.type);
    // optional pos argument
    pos = arguments.getOrDefault(2, null);
    // create list to store found items
    foundItems = [];
    // iterate over items
    for (i = 0; i < len(inventory.getItems()); i++) {
        // use ItemUtil.areEqualIgnoreNbt(item, founditem) method to compare items, returns true if items are same ignoring nbt.
        // but check if found item is not null
        if (inventory.getItems()[i] != null && ItemUtil.areEqualIgnoreNbt(item, inventory.getItems()[i])) {
            // if found, add to list
            foundItems.append([i, inventory.getItems()[i].getCount(), pos]);
        }
    }
    // if found items is not empty, return it
    if (len(foundItems) > 0) {
        return foundItems;
    }
    // else return null
    return null;
}


// function that searches item, but matches nbt too.
// returns [slot number, count, pos] if found, else null
fun searchItemFromInventory(args...) : List | Null {
    // lets use varargs
    arguments = new VarArgs(args);
    // get inventory
    inventory = arguments.get(0, ContainerInventory.type);
    // get item
    item = arguments.get(1, ItemStack.type);
    // optional pos argument
    pos = arguments.getOrDefault(2, null);
    // iterate over items
    for (i = 0; i < len(inventory.getItems()); i++) {
        // use ItemUtil.areEqualIgnoreNbt(item, founditem) method to compare items, returns true if items are same ignoring nbt.
        // but check if found item is not null
        if (inventory.getItems()[i] != null && ItemUtil.areEqualIncludeNbt(item, inventory.getItems()[i])) {
            // if found, return 
            return [i, inventory.getItems()[i].getCount(), pos];
        }
    }
    // else return null
    return null;
}
// function that searches all matching item with nbt in inventory
// returns [[slot number, count, pos]...] if found, else null
fun searchAllItemFromInventory(args...) : List | Null {
    // lets use varargs
    arguments = new VarArgs(args);
    // get inventory
    inventory = arguments.get(0, ContainerInventory.type);
    // get item
    item = arguments.get(1, ItemStack.type);
    // optional pos argument
    pos = arguments.getOrDefault(2, null);
    // create list to store found items
    foundItems = [];
    // iterate over items
    for (i = 0; i < len(inventory.getItems()); i++) {
        // use ItemUtil.areEqualIgnoreNbt(item, founditem) method to compare items, returns true if items are same ignoring nbt.
        // but check if found item is not null
        if (inventory.getItems()[i] != null && ItemUtil.areEqualIncludeNbt(item, inventory.getItems()[i])) {
            // if found, add to list
            foundItems.append([i, inventory.getItems()[i].getCount(), pos]);
        }
    }
    // if found items is not empty, return it
    if (len(foundItems) > 0) {
        return foundItems;
    }
    // else return null
    return null;
}


// lets create inventory from Pos, and search item in inventory.
// we may want additional parameter that tells if we want to close screen after operation.
// Lets use VarArgs for that.
fun searchItemAnyFromPos(args...) : Number {
    // args may contain pos, item, and closeScreen.
    arguments = new VarArgs(args);
    // get pos. we can assert type by get(index, type)
    pos = arguments.get(0, Pos.type);
    // get item. we can assert type by get(index, type)
    item = arguments.get(1, ItemStack.type);
    // get closeScreen. we can assert type by get(index, type), but its optional, so use getOrDefault(index, default, type?) method.
    closeScreen = arguments.getOrDefault(2, true, Boolean.type);
    // get World dynamically.
    world = Player.get().getWorld();
    // get inventory from pos. if closeScreen is true, we will close screen.
    inventory = ContainerInventory.ofBlock(pos, world, closeScreen);
    // search item
    return searchItemAnyFromInventory(inventory, item, pos);
}

// lets create inventory from Pos, and search item in inventory. but with nbt.
fun searchItemFromPos(args...) : Number {
    // args may contain pos, item, and closeScreen.
    arguments = new VarArgs(args);
    // get pos. we can assert type by get(index, type)
    pos = arguments.get(0, Pos.type);
    // get item. we can assert type by get(index, type)
    item = arguments.get(1, ItemStack.type);
    // get closeScreen. we can assert type by get(index, type), but its optional, so use getOrDefault(index, default, type?) method.
    closeScreen = arguments.getOrDefault(2, true, Boolean.type);
    // get World dynamically.
    world = Player.get().getWorld();
    // get inventory from pos
    inventory = ContainerInventory.ofBlock(pos, world, closeScreen);
    // search item
    return searchItemFromInventory(inventory, item, pos);
}
// function that checks if block is inventory block.
fun isInventoryBlock(world : World, pos : Pos) : Boolean {
    // get block from pos
    block = world.getBlockAt(pos);
    // get block name
    blockName = block.getId();
    // check if block name contains chest, shulker_box, hopper, furnace, dispenser, dropper, blast_furnace, smoker, brewing_stand, barrel
    if (blockName.contains('chest') || blockName.contains('shulker_box') || blockName.contains('hopper') || blockName.contains('furnace') || blockName.contains('dispenser') || blockName.contains('dropper') || blockName.contains('blast_furnace') || blockName.contains('smoker') || blockName.contains('brewing_stand') || blockName.contains('barrel')) {
        // if block is chest / shulker box / trapped chest, we need to check if its openable.
        // for chest, we need to check from pos.offset('up') is replaceable.
        // for shulker, we need to check if offset block of shulker box state's direction is empty.
        // for trapped chest, use chest method.
        // else, return true
        if (blockName.contains('chest')) {
            // check if chest is openable
            if (world.getBlockAt(pos.offset('up')).isReplaceable()) {
                // if chest is openable, return true
                return true;
            }
        } else if (blockName.contains('shulker_box')) {
            // check if shulker box is openable
            // get shulker box state
            state = block.getBlockProperties(); // this is map.
            // get direction
            direction = state['facing'];
            // get offset pos
            offsetPos = pos.offset(direction);
            // check if offset pos is empty
            if (world.getBlockAt(offsetPos).isReplaceable()) {
                // if shulker box is openable, return true
                return true;
            }
            // return false
            return false;
        } else {
            // else return true
            return true;
        }
    }
    // else return false
    return false;
}

fun getNearbyCraftingTable() : Pos | Null {
    // get Iterable of Pos
    world = Player.get().getWorld();
    // get player pos
    playerPos = Player.get().getPos();
    // pos A and B
    posA = playerPos.add(-RESTRICTION_MAP['reach_distance'], -RESTRICTION_MAP['reach_distance'], -RESTRICTION_MAP['reach_distance']);
    posB = playerPos.add(RESTRICTION_MAP['reach_distance'], RESTRICTION_MAP['reach_distance'], RESTRICTION_MAP['reach_distance']);
    // get nearby blocks
    positions = world.getPositions(posA, posB);
    // collect to list
    nearbyBlocks = [];
    foreach (pos : positions) {
        nearbyBlocks.append(pos);
    }
    // apply filter(func) to nearby blocks
    tables = nearbyBlocks.filter(fun (pos) {
        return world.getBlockAt(pos).getId().contains('crafting_table');
    });
    // sort
    tables = tables.sort(fun (posA, posB) {
        return posA.distanceTo(playerPos) - posB.distanceTo(playerPos);
    });
    // if tables is empty, return null
    if (tables.isEmpty()) {
        Logger.warn('No nearby crafting table found.');
        return null;
    }
    // return
    return tables[0];
}

// function that finds nearby Inventory positions.
fun getNearbyInventory(radius : Number){
    // get Iterable of Pos 
    world = Player.get().getWorld();
    // get player pos
    playerPos = Player.get().getPos();
    // get nearby blocks
    // getPositions accept pos a and pos b, so we need to create pos a and pos b.
    // pos a is player pos - radius
    // pos b is player pos + radius
    posA = playerPos.add(-radius, -radius, -radius);
    posB = playerPos.add(radius, radius, radius);
    // get nearby blocks
    nearbyBlocks = world.getPositions(posA, posB);
    // returnable list
    returnList = [];
    // lets iterate over nearby blocks
    foreach (pos : nearbyBlocks) {
        // check distance. if distance is greater than radius, skip.
        if (pos.distanceTo(playerPos) > RESTRICTION_MAP['reach_distance']) {
            continue;
        }
        // check if block is inventory block
        if (isInventoryBlock(world, pos)) {
            // if block is inventory block, add to return list
            returnList.append(pos);
        }
    }
    // return list
    return returnList;
}

// lets combine getNearbyInventory and searchItemFromPos, to search for item in nearby inventories.
// returns first found [slot, count, pos]
fun searchNearbyInventoryForItem(item : ItemStack, radius : Number) : List | Null {
    // get nearby inventories
    nearbyInventories = getNearbyInventory(radius);
    // iterate over nearby inventories
    for (i = 0; i < len(nearbyInventories); i++) {
        // get inventory from pos
        inventory = ContainerInventory.ofBlock(nearbyInventories[i], Player.get().getWorld(), true);
        // search for item
        result = searchItemAnyFromInventory(inventory, item, nearbyInventories[i]);
        // check if result is not null
        if (result != null) {
            // if result is not null, return result
            return result;
        }
    }
    // if not found, return null
    return null;
}

// instead of returning first found slot, we can return all found slots.
fun searchNearbyInventoryForItemAll(item : ItemStack, radius : Number) : List {
    // get nearby inventories
    nearbyInventories = getNearbyInventory(radius);
    // returnable list
    returnList = [];
    // iterate over nearby inventories
    for (i = 0; i < len(nearbyInventories); i++) {
        // get inventory from pos
        inventory = ContainerInventory.ofBlock(nearbyInventories[i], Player.get().getWorld(), true);
        // search for all matching items in inventory
        result = searchAllItemFromInventory(inventory, item, nearbyInventories[i]);
        // check if result is not null
        if (result != null) {
            // if result is not null, extend to return list
            returnList.addAll(result);
        }
    }
    // if not found, return null
    return returnList;
}


// lets try searchNearbyInventoryForItem to search for item in nearby inventories.
fun searchNearbyInventoryForFirstItem(itemName){
    // lets search for itemName in inventory
    item = ItemStack.of(itemName);
    // lets use searchNearbyInventoryForItem function
    // save as separate variable, check if value is not null, then unpack
    result = searchNearbyInventoryForItem(item, RESTRICTION_MAP["reach_distance"]);
    // check if result is not null
    if (result != null) {
        // unpack result
        slot, count, pos = result;
        // print slot number, pretty format that indicates item name, count, slot, position
        print('Found ' + item.getId() + ' with count ' + count + ' at slot ' + slot + ' at ' + pos);
    } else {
        // if not found, print not found
        print('Not found');
    }
}

// lets try finding all slots of item in nearby inventories.
// we get applier as optional parameter, to apply function for each [slot, count, pos] in list.
// we may print out each slot, or we may do something else.
fun searchNearbyInventoryForItemAllApplies(args...){
    // wrap with varargs
    arguments = new VarArgs(args);
    // get item name
    itemName = arguments.get(0);
    // get applier, if not provided, use default applier that prints found item id, count, slot, pos.
    applier = arguments.getOrDefault(1, fun(itemId, slot, count, pos) {
        print('Found ' + itemId + ' with count ' + count + ' at slot ' + slot + ' at ' + pos);
    });
    // lets search for itemName in inventory
    item = ItemStack.of(itemName);
    // lets use searchNearbyInventoryForItem function. it returns all [slot, count].
    slots = searchNearbyInventoryForItemAll(item, RESTRICTION_MAP["reach_distance"]);
    // print slot number, pretty format that indicates item name, count, slot, position for each [slot, count, pos]
    for (i = 0; i < len(slots); i++) {
        // get slot and count
        slot = slots[i][0];
        count = slots[i][1];
        pos = slots[i][2];
        // apply applier
        applier(itemName, slot, count, pos);
    }
}

// lets try finding all slots of item, but using ContainerInventory.CACHE access.
// cache contains [world, pos] as key, and inventory as value.
// we can use this to get inventory from cache, and search for item.
fun searchNearbyInventoryForItemAllCache(args...){
    // wrap with varargs
    arguments = new VarArgs(args);
    // get item name
    itemName = arguments.get(0);
    // get applier, if not provided, use default applier that prints found item id, count, slot, pos.
    applier = arguments.getOrDefault(1, fun(itemId, slot, count, pos) {
        print('Found ' + itemId + ' with count ' + count + ' at slot ' + slot + ' at ' + pos);
    });
    // cache world
    world = Player.get().getWorld();
    // lets search for itemName in inventory
    item = ItemStack.of(itemName);
    // lets directly use ContainerInventory.CACHE
    // iterate over cache
    foreach (key : ContainerInventory.CACHE) {
        // get inventory
        // check if key[0] is world
        if (key[0] != world) {
            // if not, continue
            continue;
        }
        inventory = ContainerInventory.CACHE[key];
        // check if inventory is not null
        if (inventory != null) {
            // debug items of inventory
            Logger.debug(inventory.getItems());
            // now we can search for item in inventory. result is list of [slot, count, pos]
            result = searchAllItemFromInventory(inventory, item, key[1]);
            // check if result is not null
            if (result != null) {
                // iterate over result
                for (i = 0; i < len(result); i++) {
                    // get slot, count, pos
                    slot = result[i][0];
                    count = result[i][1];
                    pos = result[i][2];
                    // apply applier
                    applier(itemName, slot, count, pos);
                }
            }
        }
    }
}


// applier that renders box around found position.
// we may need highlight library (todo)
fun renderBox(itemId, slot, count, pos) {
    box = new BoxShape(pos);
    //maybe extra
    box.setColour(255, 255, 255); // white
    box.setRenderThroughBlocks(true);
    box.setOpacity(70);
    box.render();
    RenderManager.addBox(itemId, box);
}




// function that tests querying inventory
fun testTraceInventory(){
    player = Player.get();
    // lets try to get inventory from looking block
    block = player.getLookingAtBlock(RESTRICTION_MAP["reach_distance"]);
    // get pos from block
    pos = block.getPos();
    // get inventory from pos with ContainerInventory.ofBlock
    inventory = ContainerInventory.ofBlock(pos, player.getWorld());
    itemList = inventory.getItems();
    // print item list
    print(itemList);
}


// lets try to search for item in inventory
fun testFindItemFromTrace(itemName){
    // lets search for itemName in inventory
    item = ItemStack.of(itemName);
    // lets use searchItemFromInventory function
    // first get trace pos
    pos = Player.get().getLookingAtBlock(RESTRICTION_MAP["reach_distance"]).getPos();
    // then search item
    slot, count = searchItemAnyFromPos(pos, item);
    // print slot number, pretty format that indicates item name,count, slot, position
    print('Found ' + item.getId() + ' with count ' + count + ' at slot ' + slot + ' at ' + pos);
}

// Utility class that makes class JsonSerializable
// JsonSerializable class must have a method toJson() that returns a JsonValue
// JsonSerializable class must have a static method fromJson(jsonValue) that returns a JsonSerializable object
// TODO
class JsonSerializable {
    fun toJson() : Map {
        // basic format : {'class' : 'ClassName', 'data' : { ... }}
        // we get class name from this.getClass().getName()
        // but data is defined by getSerializableData() method, which must be implemented by JsonSerializable class
        return {'class' : this.getClass().getName(), 'data' : this.getSerializableData()};
    }
    static fun fromJson(jsonValue : Map) : JsonSerializable {
        // we try to get class name from jsonValue first.
        // then with eval() we get class fromJson method
        // then we call fromJson method with jsonValue['data'] as argument
        return eval(jsonValue['class'] + ".fromJson(jsonValue['data'])");
    }
    fun getSerializableData() : Map {
        // this method must be implemented by JsonSerializable class
        throw new Error("getSerializableData() method must be implemented by JsonSerializable class");
    }
    static fun read(mapping : Map) : Object {
        // recursively reads map and converts it to object.
        // we checks if its object by finding if it has 'class' key.
        // but we will use Depth first search to convert map to object.
        // store reference key to object until its not JsonSerializable.
        // then convert it to object.
        // mapping will be modified, which means this function is in-place.
        foreach (key : mapping) {
            // get value
            value = mapping[key];
            // check if value is map
            if (value.instanceof(Map.type)) {
                // check if value is JsonSerializable
                if (value.containsKey('class')) {
                    // convert value to JsonSerializable
                    value = JsonSerializable.fromJson(value);
                }
                else {
                    // recursively read value
                    value = JsonSerializable.read(value);
                }
            }
            // else if value is list
            else if (value.instanceof(List.type)) {
                // recursively read value
                value = JsonSerializable.read();
            }
            // set value to this
            mapping[key] = value;
        }
        // finally, if mapping is Map and contains 'class' key, we convert it to JsonSerializable
        if (mapping.instanceof(Map.type) && mapping.containsKey('class')) {
            mapping = JsonSerializable.fromJson(mapping);
        }
        return mapping;
    }
}

class StrictRecipe : List {
    // StrictRecipe is Recipe based object but it contains actual ingredients and output.
    var recipe = null;
    var ingredients = null;
    var output = null;
    StrictRecipe(recipe : Recipe, ingredients : List, output : ItemStack) : super() {
        this.recipe = recipe;
        this.ingredients = ingredients;
        this.output = ImmutableItemStack.of(output);
        this.addAll(ingredients); // as List
    }

    fun toString() {
        return 'StrictRecipe(' + this.recipe + ', ' + this.ingredients + ', ' + this.output + ')';
    }

    fun getFullId() {
        return this.recipe.getFullId();
    }

    fun getIngredients() {
        // returns List of ItemStacks, this is 1d list unlike Recipe.getIngredients()
        return this.ingredients;
    }

    fun getStacks() {
        // generate frequency map for this.ingredients
        countingMap = {};
        foreach (itemStack : this.ingredients) {
            stackName = itemStack.getFullId();
            if (countingMap.containsKey(stackName)) {
                countingMap[stackName] += 1;
            }
            else {
                countingMap[stackName] = 1;
            }
        }
        return countingMap;
    }

    fun getStacks(wantedResult : Number) {
        multiplier = Math.ceil(wantedResult / this.output.getCount());
        // generate frequency map for this.ingredients
        countingMap = {};
        foreach (itemStack : this.ingredients) {
            stackName = itemStack.getFullId();
            if (countingMap.containsKey(stackName)) {
                countingMap[stackName] += multiplier;
            }
            else {
                countingMap[stackName] = multiplier;
            }
        }
        return countingMap;
    }

    fun getCraftingType() {
        return this.recipe.getCraftingType();
    }

    fun getOutput() {
        return this.output;
    }

    fun getRecipe() {
        return this.recipe;
    }

    static fun ofRecipe(recipe : Recipe, ingredients : List) : StrictRecipe {
        return new StrictRecipe(recipe, ingredients, recipe.getOutput());
    }

    static fun findStrictRecipe(recipe : Recipe) : StrictRecipe | Null {
        inventory = ScreenInventory.ofPlayerInventory().get();
        return StrictRecipe.findStrictRecipe(recipe, inventory);
    }

    static fun findStrictRecipe(recipe : Recipe, inventory : MatchableInventory) : StrictRecipe | Null {
        // by testing each item of recipe.getIngredients()[[OneOf ItemStacks...], ...], find usable items in inventory as [ItemStack, ...]
        // inventory.match(stack) -> returns list of matching items in inventory, so we can use it to find usable items.
        // then if we get [ItemStack,...], we might have duplicate entry. If its the case, we need to check if at least one item can be crafted.
        // we can use RecipeManager.calculateCraftableAmount(List, inventory) to check if at least one item can be crafted.
        // if we can craft at least one item, we can return StrictRecipe.
        // else, we need to find another item that can be crafted.
        // loop until we find StrictRecipe.
        // if we can't find StrictRecipe, return null.
        // get recipe ingredients
        ingredients = recipe.getIngredients();
        // get flat list of ingredients as [ItemStack, ...] instead of [[ItemStack, ...], ...]
        flatIngredients = Set.of();
        foreach (ingredient : ingredients) {
            flatIngredients.addAll(ingredient);
        }
        // now set is used for map's key.
        matchingMap = {};
        foreach (ingredient : flatIngredients) {
            // get matching items in inventory
            matchingItems = inventory.match(ingredient);
            // add to matchingMap
            matchingMap[ingredient] = matchingItems;
        }
        // now we have matchingMap as {ItemStack : int,...}. remove if count is 0.
        foreach (key : matchingMap) {
            // print key and value
            if (matchingMap[key] == 0) {
                matchingMap.remove(key);
            }
        }
        // for each ingredient component, - its [ItemStack, ...], map by matchingMap.get(stack) -> [count,...], then get max count.
        // then we can get max count of each ingredient.
        craftableCount = [];
        resultIngredient = [];
        // initialize resultIngredient with null using for loop
        for (i = 0; i < ingredients.size(); i++) {
            resultIngredient.append(null);
        }
        idx = 0;
        foreach (ingredient : ingredients) {
            // if ingredient is null or empty list, skip
            if (ingredient == null || ingredient.size() == 0) {
                idx++;
                continue;
            }
            // get max count of each ingredient
            maxCount = 0;
            // use for loop to memorize index and set to resultIngredient
            for (i = 0; i < ingredient.size(); i++) {
                // get ingredient
                ingredientItem = ingredient[i];
                // debug print
                // get matching count
                matchingCount = matchingMap.get(ingredientItem);
                // if matchingCount is null, set to 0
                if (matchingCount == null) {
                    matchingCount = 0;
                }
                // if matchingCount is greater than maxCount, set to maxCount
                if (matchingCount >= maxCount) {
                    maxCount = matchingCount;
                    // set to resultIngredient 
                    resultIngredient[idx] = ingredientItem;
                }
            }
            idx++;
            // add maxCount to craftableCount
            craftableCount.append(maxCount);
        }
        // now we have craftableCount as [int, ...] and resultIngredient as [ItemStack, ...]
        // we can use RecipeManager.calculateCraftableAmount(List<ItemStack>, inventory) to check if at least one item can be crafted.
        craftableAmount = RecipeManager.calculateCraftableAmount(resultIngredient, inventory);
        // if craftableAmount is 0, return null
        if (craftableAmount == 0) {
            return null;
        }
        // else, return StrictRecipe
        return new StrictRecipe(recipe, resultIngredient, recipe.getOutput());
    }

    fun iterator() : Iterator {
        return this.ingredients.iterator();
    }
}


class CraftingPlan {
    // CraftingPlan is a plan to craft item.
    // we first get targetOutput and targetAmount.
    // we finds all recipes that produces targetOutput as possibleRecipe.
    var sharedRecipes : Set = Set.of(); // Stores recipes, to check if recipe is already used. This is used to prevent infinite loop.
    var targetOutput : String = null;
    var targetMap : ItemStackMap = null;
    var targetAmount : Number = 0;
    var possibleRecipes : List = [];
    var ingredients : Map = {}; // map of ingredient to craft this plan, including child plans.
    var recipeIngredients : Map = {}; // map of ingredient to craft this plan, excluding child plans.
    var childPlans : Map = {}; // {recipeId : [CraftingPlan, ...],...}
    var isCraftable : Boolean = false; // if we can craft item, this is set to true.
    var recipe = null; // if we can craft item, this is set to recipe that can craft item.
    var inventory : MatchableInventory = null; // inventory, this is 'unique' inventory that is not being used by other plans.
    var craftingTargets : Set = Set.of(); // list of crafting targets, to avoid infinite loop.
    var stacktrace : String = "";
    var recipeList = null; // list of recipes that can craft item.
    var recursiveCount = 0;
    var externalIngredients : Map = {}; // External ingredients is ingredients that is already in inventory, but its not in player inventory.

    // fun createChildPlan(item : ItemStack | String, amount : int) : CraftingPlan  -> creates child plan that crafts item, with sharedRecipes reference.
    
    CraftingPlan(targetOutput : String, targetAmount : Number, inventory : MatchableInventory) {
        this.inventory = inventory.clone();
        this.targetOutput = targetOutput;
        this.targetAmount = targetAmount;
        this.targetMap = new ItemStackMap();
        this.targetMap.increment(ItemStack.of(targetOutput), targetAmount);
        this.stacktrace = targetOutput;
        if (RESTRICTION_MAP.get('CRAFTING_TREE') == true) {
            this.recipeList = new RecipeTree(inventory.getItems()).getRecipes();
        }
        else {
            this.recipeList = RecipeManager.ALL_RECIPES;
        }
        this.search();
    }

    CraftingPlan(targetOutput : String, targetAmount : Number, inventory : MatchableInventory, sharedRecipes : Set, craftingTargets : Set, recursiveCount : Number, stacktrace : String, inheritedRecipeTree : List) {
        this.inventory = inventory; // we don't clone here child plan should be created from forked inventory.
        this.sharedRecipes = sharedRecipes;
        this.targetOutput = targetOutput;
        this.targetAmount = targetAmount;
        this.targetMap = new ItemStackMap();
        this.targetMap.increment(ItemStack.of(targetOutput), targetAmount);
        this.craftingTargets = craftingTargets;
        this.stacktrace = stacktrace;
        this.recursiveCount = recursiveCount;
        this.recipeList = inheritedRecipeTree;
        this.search();
    }

    fun toString(){
        planType = "Plan";
        if (this.isCraftable) {
            planType = "CraftablePlan";
        }
        if (this.childPlans.size() == 0) {
            // if recipe is null, return "Plan<recipe : null>";
            if (this.recipe == null) {
                return planType + "<recipe : null>";
            }
            return planType + "<recipe : " + this.recipe.getFullId()+ ">";
        }
        else {
            recipeId = "";
            if (this.recipe == null) {
                recipeId = "null";
            }
            else {
                recipeId = this.recipe.getFullId();
            }
            childs =  planType + "<recipe " + recipeId+ ", childs :[";
            childs += this.childPlans.toString();
            childs += "]>";
            return childs;
        }
    }
    // example : CraftingPlan.of("minecraft:hopper", 64);
    // CraftingPlan.of("minecraft:hopper", amount).pretty(); -> test
    static fun of(targetOutput : String, targetAmount : Number) : CraftingPlan{
        // create CraftingPlan with current player inventory.
        playerInventory = ScreenInventory.ofPlayerInventory().get();
        return new CraftingPlan(targetOutput, targetAmount, playerInventory);
    }

    static fun ofNearby(targetOutput : String, targetAmount : Number) {
        // use MergedInventory.ofNearby() to get inventory.
        nearbyInventory = MergedInventory.ofNearby();
        // add player inventory to nearbyInventory
        nearbyInventory.addPlayerInventory();
        // debug match iron nugget count and print
        return new CraftingPlan(targetOutput, targetAmount, nearbyInventory);
    }

    fun pretty(){
        // pretty print that shows this.toString, then if this is craftable, print all required recipes and ingredients. else just print that it is not craftable.
        Logger.info(this.toString());
        if (this.isCraftable) {
            Logger.info("Plan is craftable");
            Logger.info("Required recipes : ");
            Logger.info(this.getRequiredRecipes());
            Logger.info("Required ingredients (exclusive): ");
            Logger.info(this.recipeIngredients);
        } else {
            Logger.info("Plan is not craftable");
        }
    }

    fun getRequiredRecipes(){
        if (!this.isCraftable) {
            Logger.warn("can't get required recipes for non-craftable plan for item " + this.targetOutput );
            return null;
        }
        // get all recipes that are required to craft this plan. this includes child plans.
        recipes = {}; // {recipeId : int,...} -> int is amount of recipe used. if recipe is used multiple times, it is incemented. If key is not in map, it is set to amount.
        // add recipe of this plan
        if (this.recipe != null) {
            recipeOutputCount = this.recipe.getOutput().getCount();
            recipes[this.recipe.getFullId()] = this.targetAmount / recipeOutputCount;
        }
        // add child plans
        foreach (recipeId : this.childPlans) {
            foreach (childPlan : this.childPlans[recipeId]) {
                // get childPlan's required recipes
                childRecipes = childPlan.getRequiredRecipes();
                // add to recipes
                foreach (childRecipeId : childRecipes) {
                    if (recipes[childRecipeId] == null) {
                        recipes[childRecipeId] = childRecipes[childRecipeId];
                    } else {
                        recipes[childRecipeId] += childRecipes[childRecipeId];
                    }
                }
            }
        }
        return recipes;   
    }
     
    fun createChildPlan(item : ItemStack | String, amount : Number, inventory : MatchableInventory) : CraftingPlan {
        // create child plan
        if (item.instanceOf(ItemStack.type)) {
            Assert.assert(item.getFullId() != this.targetOutput, "can't create child plan for same item as parent plan");
        }
        else {
            itemName = item;
            Assert.assert(item != this.targetOutput, "can't create child plan for same item as parent plan");
        }
        Assert.assert(this.recursiveCount < 6, "max recursive count reached.");
        craftingTargets = Set.of();
        craftingTargets.addAll(this.craftingTargets);
        Logger.debug(this.stacktrace + " < " + item);
        craftingTargets.add(this.targetOutput);
        // debug for craftingTargets
        childPlan = new CraftingPlan(item, amount * this.targetAmount, inventory, this.sharedRecipes.copy(), craftingTargets, this.recursiveCount + 1, this.stacktrace + " < " + item, this.recipeList);
        // return childPlan
        return childPlan;
    }

    fun search() {
        Logger.actionCounter(this.stacktrace);
        Logger.debug("searching for " + this.targetOutput + " x " + this.targetAmount);
        if (this.inventory == null) {
            Logger.error("inventory is null");
            return;
        }
        containsAmount = this.inventory.match(ItemStack.of(this.targetOutput), false);
        containsAmount = Math.min(containsAmount, this.targetAmount);
        if (containsAmount > 0) {
            playerInv = this.inventory.getPlayerInventory();
            playerAmount = 0;
            if (playerInv != null) {
                playerAmount = playerInv.match(ItemStack.of(this.targetOutput), false);
            }
            else {
                playerAmount = 0;
            }
            if (containsAmount - playerAmount > 0) {
                this.externalIngredients = {this.targetOutput : containsAmount - playerAmount};
            }
        }
        clonedInventory = this.inventory;
        if (containsAmount >= this.targetAmount) {
            Logger.debug("Planned recipe for already existing item : " + this.targetOutput + " x " + this.targetAmount);
            // calculate externalIngredients, the amount of items that has to be moved.
            this.isCraftable = true;
            this.ingredients = {};
            return;
        }
        else if (containsAmount > 0) {
            Logger.debug("inventory contains " + this.targetOutput + " x " + containsAmount + ", but not enough");
            this.targetAmount -= containsAmount;
            clonedInventory = this.inventory.clone();
            extracted = clonedInventory.extract(ItemUtil.of(this.targetOutput, containsAmount), containsAmount);
            Assert.assert(extracted == containsAmount, "Extracted size is not equal to containsAmount");
        }
        // else, search child plans
        // get all recipes that produces targetOutput
        possibleRecipes = this.recipeList.filter(fun (recipe){
            return recipe.getOutput().getFullId() == this.targetOutput;
        });
        // if possibleRecipes is empty, set isSearchComplete to true and return
        if (possibleRecipes.size() == 0) {
            this.isCraftable = false;
            return;
        }
        // else, create child plans
        foreach (recipe : possibleRecipes) {
            // if recipe is already used, skip
            if (this.sharedRecipes.contains(recipe)) {
                Logger.debug("skipping recipe " + recipe.getFullId() + " because it is already used");
                continue;
            }
            // if craftingTarget already contains recipe's output, skip
            if (this.craftingTargets.contains(recipe.getOutput().getFullId())) {
                Logger.debug("skipping recipe " + recipe.getFullId() + " because it is already used as crafting target, current plan : "+ this.stacktrace);
                continue;
            }
            // StrictRecipe.findStrictRecipe returns StrictRecipe if it can find recipe that can craft item.
            possibleRecipe = StrictRecipe.findStrictRecipe(recipe, clonedInventory);
            if (possibleRecipe != null && RecipeManager.calculateCraftableAmount(possibleRecipe, clonedInventory) >= this.targetAmount) {
                // debug
                Logger.debug("possibleRecipe : " + possibleRecipe.getFullId() + " can craft " + this.targetAmount + " " + this.targetOutput);
                // if possibleRecipe is not null, set isCraftable to true and set recipe to possibleRecipe
                // check amount that can be crafted.
                Logger.debug("found recipe " + recipe.getFullId() + " that can craft " + this.targetAmount + " " + this.targetOutput);
                this.isCraftable = true;
                this.recipe = possibleRecipe;
                this.calculateIngredients();
                return;
            }
            // add recipe to sharedRecipes, so that other plans don't use it.
            // debug
            this.sharedRecipes.add(recipe);
            recipeOutputCount = recipe.getOutput().getCount();
            recipeIngredientCombinations = new CombinedIterable(recipe.getIngredients());
            testRecipes = Set.of();
            foreach (recipeIngredientCombination : recipeIngredientCombinations) {
                Logger.actionCounter("testing childs : "+ recipeIngredientCombination);
                if (testRecipes.contains(Set.of().addAll(recipeIngredientCombination))){
                    continue;
                }
                testRecipes.add(Set.of().addAll(recipeIngredientCombination));
                // flat list of ingredients
                ingredients = {}; // frequencyMap
                foreach (ingredient : recipeIngredientCombination) {
                    // ingredient is [ItemStack, ,ItemStack, ...] and we choose one of them if available
                    // if ingredient is null, skip
                    if (ingredient == null) {
                        continue;
                    }
                    // else, add to ingredients
                    // if ingredient is already in ingredients, increment count
                    if (ingredients.containsKey(ingredient.getFullId())) {
                        ingredients[ingredient.getFullId()] += 1 / recipeOutputCount;
                    }
                    // else, set to 1
                    else {
                        ingredients[ingredient.getFullId()] = 1 / recipeOutputCount;
                    }
                }
                // create child plan for each ingredient
                recipeChildPlans = [];
                canCraft = ingredients.size() > 0;
                clonedInventory = clonedInventory.clone(); // clone inventory for child plan.
                foreach (ingredient : ingredients.getKeys()) {
                    // create child plan
                    // check if child plan is craftable
                    possibleChildRecipes = this.recipeList.filter(fun (recipe){
                        return recipe.getOutput().getFullId() == ingredient;
                    });
                    if (possibleChildRecipes.size() == 0) {
                        canCraft = false;
                        break;
                    }
                    childPlan = this.createChildPlan(ingredient, ingredients[ingredient], clonedInventory);
                    if (childPlan.isCraftable) {
                        // takeAll items from clonedInventory
                        clonedInventory = clonedInventory.clone();
                        // debug getRequiredItems and getExternalItems are being taken
                        Assert.assert(clonedInventory.takeAll(childPlan.getRequiredItems()).isEmpty(), "Required items are not taken from clonedInventory: " + childPlan.getRequiredItems());
                        Assert.assert(clonedInventory.takeAll(childPlan.getExternalItems()).isEmpty(), "External items are not taken from clonedInventory : " + childPlan.getExternalItems() + 
                        "\n clonedInventory : "+ clonedInventory);
                        recipeChildPlans.append(childPlan);
                    }
                    else {
                        canCraft = false;
                        break;
                    }
                }
                if (canCraft) {
                    // if all child plans are craftable, set isCraftable to true and set recipe to recipe
                    this.isCraftable = true;
                    // debug recipe and recipeIngredientCombination
                    strict = StrictRecipe.ofRecipe(recipe, recipeIngredientCombination);
                    this.recipe = strict;
                    this.childPlans.put(recipe.getFullId(), recipeChildPlans);
                    this.calculateIngredients();
                    return;
                }
            }
        }
        this.isCraftable = false;
    }

    fun craft(){
        // craft this plan
        // if this is not craftable, throw exception if DEBUG_FLAG is true
        if (!this.isCraftable) {
            if (DEBUG_FLAG) {
                throw new Error("this plan is not craftable");
            }
            return;
        }

        // if this is craftable, craft this plan
        // if this is not leaf plan, craft child plans first
        if (this.childPlans.size() > 0) {
            foreach (key : this.childPlans.getKeys()) {
                foreach (childPlan : this.childPlans[key]) {
                    Assert.assert(childPlan.isCraftable, "child plan is not craftable");
                    childPlan.craft();
                }
            }
        }
        foreach (item : this.getExternalItems()) {
            Logger.actionCounter("moving item : " + item.getFullId() +" x " +item.getCount() +" which is not in inventory");
            Logger.info("moving item : " + item.getFullId() + " x " +item.getCount() + " which is not in inventory");
            Assert.assert(this.inventory.match(item, false) >= item.getCount(), "inventory does not match item : " + item.getFullId() + " x " + item.getCount());
            movedAmount = this.inventory.moveFrom(item, item.getCount());
            Assert.assert(movedAmount == item.getCount(), "Cannot move item : " + item.getFullId() + " x " + item.getCount() + ", moved amount : " + movedAmount + " but required amount : " + item.getCount());
        }
        // craft this plan with recipe.
        // take required items from inventory by moveFrom method
        foreach (item : this.getRequiredItems()) {
            Logger.actionCounter("moving item : " + item.getFullId() + " for crafting material");
            Logger.info("moving item : " + item.getFullId() + " x " +item.getCount() + " for crafting material");
            movedAmount = this.inventory.moveFrom(item, item.getCount());
            Assert.assert(movedAmount == item.getCount(), "Cannot move item : " + item.getFullId() + " x " + item.getCount() + ", moved amount : " + movedAmount + " but required amount : " + item.getCount());
        }
        if (this.recipe == null) {
            return;
        }
        // craft with recipe
        RecipeManager.craftRecipe(this.recipe, this.targetAmount);
    }

    // fun getRequiredIngredients() : Map -> returns map of ingredient to craft this plan, including child plans.
    // {String : int, ...}
    fun getRequiredIngredients() : Map {
        // debug this.targetOutput and this.ingredients
        Assert.assert(this.isCraftable, "Cannot craft but getRequiredIngredients is called");
        return this.ingredients;
    }

    fun getRequiredItems() : List {
        // creates Stack from ingredients and returns it.
        items = [];
        foreach (ingredient : this.recipeIngredients.getKeys()) {
            item = ItemStack.of(ingredient);
            item.setStackSize(Math.ceil(this.recipeIngredients[ingredient]));
            items.append(item);
        }
        return items;
    }

    // converts this.externalIngredients to List of ItemStack
    fun getExternalItems() : List {
        items = [];
        foreach (ingredient : this.externalIngredients.getKeys()) {
            item = ItemStack.of(ingredient);
            item.setStackSize(Math.ceil(this.externalIngredients[ingredient]));
            items.append(item);
        }
        return items;
    }

    // private 
    fun calculateIngredients(){
        // this is always called when search is completed.
        // if isCraftable is false, return
        Assert.assert(this.isCraftable, "Cannot craft but calculateIngredients is called");
        // else, calculate from this.recipe -> {itemFullId : amount, ...} by creating map as frequencyMap
        ingredients = {}; // frequencyMap
        // if this.childPlans is not empty, add all ingredients from child plans, else just calculate from this.recipe
        if (this.childPlans.isEmpty() ) {
            if (this.recipe == null) {
                Assert.assert(!this.ingredients.isEmpty(), "this.ingredients is empty");
                return this.ingredients;
            }
            recipeOutputCount = this.recipe.getOutput().getCount();
            foreach (ingredient : this.recipe.getIngredients()) {
                // ingredient is [ItemStack, ,ItemStack, ...] and we choose one of them if available
                // if ingredient is null, skip
                if (ingredient == null) {
                    continue;
                }
                // else, add to ingredients
                // if ingredient is already in ingredients, increment count
                if (ingredients.containsKey(ingredient.getFullId())) {
                    ingredients[ingredient.getFullId()] += this.targetAmount / recipeOutputCount;
                }
                // else, set to 1
                else {
                    ingredients[ingredient.getFullId()] = this.targetAmount / recipeOutputCount;
                }
            }
            this.ingredients = ingredients;
            this.recipeIngredients = ingredients.copy();
            return;
        }
        else {
            // add all ingredients from child plans
            // this.childPlans : {recipeId : [CraftingPlan, ...],...}
            foreach (childPlan : this.childPlans.getValues()) {
                // childPlan : [CraftingPlan, ...]
                foreach (plan : childPlan) {
                    // plan : CraftingPlan
                    childIngredients = plan.getRequiredIngredients();
                    foreach (ingredient : childIngredients.getKeys()) {
                        // if ingredient is already in ingredients, increment count
                        if (ingredients.containsKey(ingredient)) {
                            ingredients[ingredient] += childIngredients[ingredient];
                        }
                        // else, set to 1
                        else {
                            ingredients[ingredient] = childIngredients[ingredient];
                        }
                    }
                }
            }
            this.ingredients = ingredients;
            return;
        }
    }

}
// class ImmutableItemStack wraps ItemStack and makes it immutable.
class ImmutableItemStack {
    var item;
    ImmutableItemStack(item : ItemStack) {
        this.item = item;
    }

    static fun of(item : ItemStack | String) : ImmutableItemStack {
        if (item.instanceOf(String.type)) {
            item = ItemStack.of(item);
            return new ImmutableItemStack(item);
        }
        return new ImmutableItemStack(item);
    }

    fun getFullId() : String {
        return this.item.getFullId();
    }

    fun getCount() : Number {
        return this.item.getCount();
    }

    fun getMaxCount() : Number {
        return this.item.getStackSize();
    }

    fun setStackSize(count : Number) {
        Assert.assert(false, "Cannot set count of ImmutableItemStack");
    }

    fun getNbt() {
        return this.item.getNbt();
    }

    fun setNbt(nbt) {
        Assert.assert(false, "Cannot set nbt of ImmutableItemStack");
    }
}
class RecipeTree {
    // we first have all recipes as var unused.
    // then we move recipes that is related with items in this.items to var used.
    // then we move items to checkeditems and remove them from this.items.
    // then we repeat
    var items = Set.of();
    var checkeditems = Set.of();
    var unused = Set.of();
    var used = Set.of();

    // usage : some iterable -> RecipeTree -> getRecipes() -> List to filter small set of recipes
    RecipeTree(itemIterable : Iterable) {
        Assert.assert(itemIterable.size() > 0, "Empty items for RecipeTree");
        // use add method with wrapping items as .getFullId()
        items = [];
        foreach (item : itemIterable) {
            if (item == null) continue;
            items.append(ItemUtil.getFullId(item));
        }
        this.items.addAll(items);
        this.unused.addAll(RecipeManager.SELECTED_RECIPES);
        this.calculate();
    }

    RecipeTree(itemIterable : Iterable, useAllRecipe : Boolean) {
        Assert.assert(itemIterable.size() > 0, "Empty items for RecipeTree");
        // use add method with wrapping items as .getFullId()
        items = [];
        foreach (item : itemIterable) {
            if (item == null) continue;
            items.append(ItemUtil.getFullId(item));
        }
        this.items.addAll(items);
        if (useAllRecipe) {
            this.unused.addAll(Recipe.ALL.filter(fun (recipe){
                return recipe.getCraftingType() == 'crafting';
            }););
        }
        else {
            this.unused.addAll(RecipeManager.SELECTED_RECIPES);
        }
        this.calculate();
    }

    fun calculate(){
        if (this.items.isEmpty()) {
            // debug : print size of unused
            return;
        }
        // get first item from this.items
        itemList = this.items.toList();
        while (itemList.size() > 0) {
            Logger.actionCounter("RecipeTree.calculate() processing");
            item = itemList.remove(0);
            this.checkeditems.add(item);
            // get all recipes that contains item as input
            recipes = RecipeManager.findContainsId(item, this.unused);
            foreach (recipe : recipes){
                if (this.test(recipe)) {
                    // if recipe is craftable, add to used
                    this.used.add(recipe);
                    this.unused.remove(recipe);
                    if (this.containsItem(recipe.getOutput().getFullId())) {
                        continue;
                    }
                    itemList.append(recipe.getOutput().getFullId());
                    this.items.add(item);
                }
            }
            // add item to checkeditems
            this.checkeditems.add(item);
        }
        this.items.clear();
    }

    fun getRecipes() : List {
        // debug
        return this.used.toList();
    }

    fun containsItem(target) : Boolean {
        return this.items.contains(ItemUtil.getFullId(target)) || this.checkeditems.contains(ItemUtil.getFullId(target));
    }

    fun test(recipe : Recipe) : Boolean {
        // Recipe is craftable if all ingredients are in checkeditems
        // recipe.getIngredients() : [[ItemStack, ...], ...], we choose one of them if available
        isAllIn = true;
        foreach (ingredients : recipe.getIngredients()) {
            // if ingredient is null, skip
            // print ingredients
            if (ingredients == null || ingredients.isEmpty()) {
                continue;
            }
            ingredientFound = false;
            // ingredients = [ItemStack, ...]
            // if any of ingredients are in checkeditems, mark true, else false
            foreach (ingredient : ingredients) {
                // assert ingredient is ItemStack
                Assert.assert(ingredient.instanceOf(ItemStack.type), "Ingredient is not ItemStack");
                if (this.containsItem(ingredient)) {
                    ingredientFound = true;
                    break;
                }
            }
            // cannot find ingredient, return false
            if (!ingredientFound) {
                isAllIn = false;
                break;
            }
        }
        return isAllIn;
    }
}


class RecipeManager {
    // Objective : given item, find recipe that produces that item.
    // we might need to find recipe recursively to produce final item.
    // Inventories are given as input, we can use items inside inventories to produce final item.
    // Recipe.ALL is a list of all recipes as [Recipe, ...]
    // Recipe has .getFullId, .getOutput, .getIngredients methods.

    static var USE_CRAFT_EXTERNAL = true; // uses player.craft() method, but it crafts whole stack.

    static var ALL_RECIPES = Recipe.ALL.filter(fun (recipe){
        return recipe.getCraftingType() == 'crafting';
    });

    static var SELECTED_RECIPES = Recipe.ALL.filter(fun (recipe){
        return recipe.getCraftingType() == 'crafting';
    });
    static var RECIPE_CACHE = {}; // stores {itemFullId : [Recipe..]} for faster search
    static var REFERENCE_CACHE = {}; // stores {itemFullId : [Recipe..]} for faster search
    var recipe = null;
    RecipeManager(recipe : Recipe) {
        this.recipe = recipe;
    }

// saveTask(optionName, optionValueSupplier) : saves optionValueSupplier() to file.
// loadTask(optionName, optionValueSetter) : loads file and calls optionValueSetter(value).
    static fun saveRecipes() {
        // saves SELECTED_RECIPES to file
        saveTask("recipes", fun () {
            return RecipeManager.SELECTED_RECIPES.map(fun (recipe){
                return recipe.getFullId();
            });
        });
    }

    static fun loadRecipes() {
        // loads SELECTED_RECIPES from file
        loadTask("recipes", fun (value) {
            RecipeManager.SELECTED_RECIPES = value.map(fun (recipeFullId){
                return Recipe.of(recipeFullId);
            });
        });
    }

    static fun suggestSelectedRecipe() {
        return RecipeManager.SELECTED_RECIPES.map(fun (recipe){
            return recipe.getFullId();
        });
    }

    static fun resetSelectedRecipes() {
        RecipeManager.SELECTED_RECIPES = Recipe.ALL.filter(fun (recipe){
            return recipe.getCraftingType() == 'crafting';
        });
    }

    static fun emptyRecipes() {
        RecipeManager.SELECTED_RECIPES = [];
    }

    static fun addRecipe(recipe : Recipe) {
        if (Recipes.SELECTED_RECIPES.contains(recipe)) return;
        RecipeManager.SELECTED_RECIPES.append(recipe);
    }

    static fun removeRecipe(recipe : Recipe) {
        if (!Recipes.SELECTED_RECIPES.contains(recipe)) return;
        RecipeManager.SELECTED_RECIPES.remove(recipe);
    }

    static fun addRecipeOfPlayer() {
        // new RecipeTree(inventory.getItems()).getRecipes(); // get all recipes that can be crafted with items in inventory
        // new RecipeTree([ItemStack, ...]).getRecipes(); // get all recipes that can be crafted with given items
        inventory = ScreenInventory.ofPlayerInventory().get();
        RecipeManager.SELECTED_RECIPES.addAll(new RecipeTree(inventory.getItems(), true).getRecipes());
    }
    static fun addRecipeOfNearby() {
        // new RecipeTree(inventory.getItems()).getRecipes(); // get all recipes that can be crafted with items in inventory
        // new RecipeTree([ItemStack, ...]).getRecipes(); // get all recipes that can be crafted with given items
        inventory = MergedInventory.ofNearby();
        RecipeManager.SELECTED_RECIPES.addAll(new RecipeTree(inventory.getItems(), true).getRecipes());
    }
    static fun addRecipeOfItem(item : ItemStack) {
        foreach (recipe : new RecipeTree([item], true).getRecipes()){
            RecipeManager.addRecipe(recipe);
        }
    }
    static fun addRecipeOf(string : String) {
        RecipeManager.addRecipe(Recipe.of(string));
    }

    static fun findMatching(resultItem : ItemStack) : List{
        // iterate over RecipeManager.SELECTED_RECIPES and find matching recipe which result is resultItem
        // returns [Recipe,...]
        if (RecipeManager.RECIPE_CACHE.containsKey(resultItem.getFullId())) return RecipeManager.RECIPE_CACHE[resultItem.getFullId()];
        result = RecipeManager.SELECTED_RECIPES.filter(fun(recipe) {
            return ItemUtil.areEqualIgnoreNbt(recipe.getOutput(), resultItem);
        });
        // cache result
        RecipeManager.RECIPE_CACHE[resultItem.getFullId()] = result;
        return result;
    }

    static fun findContains(ingredientItem : ItemStack) : List{
        // iterate over RecipeManager.SELECTED_RECIPES and find matching recipe which contains ingredientItem
        // returns [Recipe,...]
        // use REFERENCE_CACHE to cache result
        if (RecipeManager.REFERENCE_CACHE.containsKey(ingredientItem.getFullId())) return RecipeManager.REFERENCE_CACHE[ingredientItem.getFullId()];
        result = RecipeManager.SELECTED_RECIPES.filter(fun(recipe) {
            return !recipe.getIngredients().filter(fun (itemLists) {
                return !itemLists.filter(fun (item) {
                    return ItemUtil.areEqualIgnoreNbt(item, ingredientItem);
                }).isEmpty();
            }).isEmpty(); // better if any is implemented
        });
        // cache result
        RecipeManager.REFERENCE_CACHE[ingredientItem.getFullId()] = result;
        return result;
    }

    // String version of findMatching and findContains - findMatchingId / findContainsId dynamically uses getFullId() method
    static fun findMatchingId(resultItem : String) : List{
        // iterate over RecipeManager.SELECTED_RECIPES and find matching recipe which result is resultItem
        // returns [Recipe,...]
        if (RecipeManager.RECIPE_CACHE.containsKey(resultItem)) return RecipeManager.RECIPE_CACHE[resultItem];
        result = RecipeManager.SELECTED_RECIPES.filter(fun(recipe) {
            return recipe.getOutput().getFullId()== resultItem;
        });
        // cache result
        RecipeManager.RECIPE_CACHE[resultItem] = result;
        return result;
    }

    static fun findContainsId(ingredientItem : String) : List{
        // iterate over RecipeManager.SELECTED_RECIPES and find matching recipe which contains ingredientItem
        // returns [Recipe,...]
        // use REFERENCE_CACHE to cache result
        if (RecipeManager.REFERENCE_CACHE.containsKey(ingredientItem)) return RecipeManager.REFERENCE_CACHE[ingredientItem];
        result = RecipeManager.SELECTED_RECIPES.filter(fun(recipe) {
            return !recipe.getIngredients().filter(fun (itemLists) {
                return !itemLists.filter(fun (item) {
                    return item.getFullId() == ingredientItem;
                }).isEmpty();
            }).isEmpty(); // better if any is implemented
        });
        // cache result
        RecipeManager.REFERENCE_CACHE[ingredientItem] = result;
        return result;
    }

    static fun findContainsId(ingredientItem : String, recipeLists : Set | List) : Set | List{
        // iterate over recipeLists and find matching recipe which contains ingredientItem
        // returns [Recipe,...]
        // use REFERENCE_CACHE to cache result
        if (RecipeManager.REFERENCE_CACHE.containsKey(ingredientItem)) return RecipeManager.REFERENCE_CACHE[ingredientItem];
        result = recipeLists.filter(fun(recipe) {
            return !recipe.getIngredients().filter(fun (itemLists) {
                return !itemLists.filter(fun (item) {
                    return item.getFullId() == ingredientItem;
                }).isEmpty();
            }).isEmpty(); // better if any is implemented
        });
        return result;
    }
    static fun tryCraftItem(item : ItemStack | String, amount : Number) : Number {
        // if item is String, convert to ItemStack with ItemStack.of(item)
        if (item.instanceOf(String.type)) {
            item = ItemStack.of(item);
        }
        recipes = RecipeManager.findMatching(item);
        // if no recipe found, return 0
        if (len(recipes) == 0) {
            Logger.info('No recipe found for ' + item);
            return 0;
        }
        // else, try to craft recipe with given amount until accumulated amount is equal or greater than given amount
        // if no recipe can be crafted, return crafted amount
        crafted = 0;
        foreach (recipe : recipes) {
            // debug
            Logger.info('trying recipe ' + RecipeManager.prettyFormat(recipe));
            crafted += RecipeManager.tryCraftRecipe(recipe, amount - crafted);
            if (crafted >= amount) break;
        }
        return crafted;
    }

    // tries to craft recipe with given amount. returns amount of items crafted.
    static fun tryCraftRecipe(recipe : Recipe, amount : Number) : Number {
        // first findStrictRecipe
        // then craft recipe with given amount
        strictRecipe = StrictRecipe.findStrictRecipe(recipe);
        if (strictRecipe == null) return 0;
        crafted = RecipeManager.craftRecipe(strictRecipe, amount);
        return crafted;
    }
    static fun prettyFormat(recipe : Recipe) : String {
        // pretty format recipe
        // get recipe full id
        fullId = recipe.getFullId();
        // get recipe output
        output = recipe.getOutput();
        // get recipe ingredients
        ingredients = recipe.getIngredients();
        // pretty format
        return fullId + ' -> ' + output.getId() + ' with ' + ingredients;
    }
    // try crafting item in Runtime. returns  amount of items crafted.
    // this function does not provide item movement, so you should move items before calling this function.
    static fun craftRecipe(recipe : StrictRecipe, amount : Number) : Number {
        if (amount == 0) return 0; 
        // check if its standard craftable recipe without blockEntity.
        // check if its 2x2 or 3x3 recipe by size
        requiresCraftingTable = len(recipe) > 4;
        // check current screen is crafting table or not
        currentScreenName = ScreenInventory.getCurrentScreenName();
        // if currentScreenName is null, isCraftingTable is false, else check if currentScreenName contains 'Crafting'\
        isCraftingTable = currentScreenName != null && currentScreenName.contains('Crafting');
        // if requires crafting table, but not crafting table, plan to open crafting table.
        if (requiresCraftingTable && !isCraftingTable) {
            // open crafting table
            craftingTablePos = getNearbyCraftingTable();
            if (craftingTablePos == null) {
                // if there is no crafting table nearby, return
                Logger.error('Failed to find nearby crafting table');
                return 0;
            }
            // close current screen
            ScreenInventory.closeScreen();
            // open crafting table
            // wait for crafting table to open
            // try 10 times
            for (i = 0; i < ScreenInventory.MAX_TRIES; i++) {
                Logger.info("Trying to open crafting table");
                Player.get().interactBlock(craftingTablePos, 'up');
                // wait for 1 second
                sleep(ScreenInventory.WAIT_TIME * 1000);
                currentScreenName = ScreenInventory.getCurrentScreenName();
                isCraftingTable = currentScreenName != null && currentScreenName.contains('Crafting');
                if (isCraftingTable) break;
            }
            if (!isCraftingTable) {
                // if crafting table is not opened, return
                Logger.error('Failed to open crafting table at ' + craftingTablePos);
                ItemManager.terminate();
                return 0;
            }
        }
        if (!requiresCraftingTable) {
            // we don't need crafting table. We need to check if screen is PlayerInventory Screen.
            if (!ScreenInventory.isPlayerInventoryScreen()) {
                //if not null and not 'Chat' and not 'Inventory', close screen
                screenName = ScreenInventory.getCurrentScreenName();
                if (screenName != null && screenName != 'Chat' && !ScreenInventory.isPlayerInventoryScreen()) {
                    ScreenInventory.closeScreen();
                }
                // try for 10 times until player inventory is opened.
                Player.get().openInventory();
                for (i = 0; i < ScreenInventory.MAX_TRIES; i++) {
                    // debug count of tries
                    sleep(ScreenInventory.WAIT_TIME * 1000);
                    if (ScreenInventory.isPlayerInventoryScreen()) break;
                }
                sleep(ScreenInventory.WAIT_TIME * 1000);
                if (!ScreenInventory.isPlayerInventoryScreen()) {
                    Logger.error('Failed to open player inventory');
                    ItemManager.terminate();
                    return 0;
                }
            }
        }
        // here we can assume that crafting table or screen is opened.
        // 0 is always output slot
        // 1,2,3,4,5,6,7,8,9 are crafting slots in 3x3 - with requiresCraftingTable boolean controlled. (when true)
        // while 1, 2, 3, 4 is crafting slots in 2x2 - with requiresCraftingTable boolean controlled.(when false)
        // we assume ALL items are already inside player inventory.
        // we will move items from player inventory to crafting table.
        // after crafting, we will move items from crafting table to player inventory by shift clicking slot 0

        // get player inventory and crafting table inventory
        playerInventory = ScreenInventory.ofPlayerInventory().get();
        craftingTableInventory = CraftingInventory.ofCraftingGrid(requiresCraftingTable);
        craftableAmount = RecipeManager.calculateCraftableAmount(recipe, playerInventory);
        // take minimum of craftableAmount and amount
        craftableAmount = Math.min(craftableAmount, amount);
        // if craftableAmount is 0, return
        if (craftableAmount == 0) {
            // we can't craft anything, return
            requiredStacks = recipe.getStacks(amount);
            Logger.info('Failed to craft ' + amount + ' of ' + recipe.getOutput().getFullId() + ' because there is no enough items in player inventory.');
            Logger.info("Required items: " + requiredStacks);
            ItemManager.terminate(); 
            return 0;
        }
        // debug craftable amount
        Logger.info('Crafting ' + craftableAmount + ' of ' + recipe.getOutput().getFullId());
        // now we can craft craftableAmount of items.
        // move items from player inventory to crafting table.
        // we will use .moveStackToExternalSlot(stack, amount, slot) method.
        // craftingTableInventory has inputSlots property that contains all input slot numbers, and outputSlot property that contains output slot numbers
        // iterate over input slots, and move items from player inventory to crafting table's input slots.
        // each time, we can only create 64 times.
        // thus loop for amount / 64 times.
        if (RecipeManager.USE_CRAFT_EXTERNAL) {
            for (i = 0; i < Math.ceil(craftableAmount / recipe.getOutput().getCount()); i++) {
                Player.get().clickRecipe(recipe.getRecipe());
                ScreenInventory.shiftClickSlot(0);
            }
            sleep(ScreenInventory.WAIT_TIME * 1000);
        }
        else {
            for (i = 0; i < Math.ceil(craftableAmount / 64); i++) {
                // iterate over input slots but use for loop. craftingTableInventory.inputSlots[i] is slot number, and recipe[i] is item.
                for (j = 0; j < len(recipe); j++) {
                    // get item from recipe, 
                    item = recipe.get(j);
                    // debug that we are moving item to crafting table
                    // move item to crafting table
                    playerInventory.moveStackToExternalSlot(item, craftableAmount, j + 1);
                }
                ScreenInventory.shiftClickSlot(0);
                sleep(ScreenInventory.WAIT_TIME * 1000);
            }
        }
        // return
        ItemManager.terminate();
        return craftableAmount;
    }

    static fun calculateCraftableAmount(recipe : StrictRecipe | List, playerInventory : MatchableInventory) : Number {
        // first, we need to merge items in recipe.
        // We will ignore NBT data for now. lets calculate recipe: [ItemStack, ...] -> {fullId : matches} transformation.
        frequencyMap = RecipeManager.transformRecipeIntoItemMap(recipe);
        // now we have frequency map, we can calculate how many times we can craft.
        // for each keys in frequencyMap, use predicate to find item in player inventory. playerInventory has .matchPredicate method that returns total number of items that matches predicate.
        matchMap = {};
        recipeOutputCount = 1;
        if (recipe.instanceOf(StrictRecipe.type)) {
            recipeOutputCount = recipe.getOutput().getCount();
        }
        foreach (key : frequencyMap.getKeys()) {
            // get item from key
            item = ItemStack.of(key);
            // get matches
            matches = playerInventory.matchPredicate(fun (itemStack) {
                return itemStack.getId() == item.getId();
            });
            // put matches into matchMap
            matchMap[key] = matches;
        }
        // now we have matchMap, we can calculate how many times we can craft by dividing matches by frequencyMap value, and taking minimum then Math.floor() it.
        // we will use minMatches to store minimum matches.
        minMatches = 10000; // very large number
        foreach (key : frequencyMap.getKeys()) {
            // get matches
            matches = matchMap[key];
            // get frequency
            frequency = frequencyMap[key];
            // calculate how many times we can craft
            times = matches / frequency;
            // if minMatches is null, initialize it to times, else if times is smaller than minMatches, update minMatches to times.
            if (minMatches == 10000) {
                minMatches = times;
            } else if (times < minMatches) {
                minMatches = times;
            }
        }
        if (minMatches == 10000) {
            // we can't craft anything, return 0
            return 0;
        }
        // now we have minMatches, we can return it.
        return Math.floor(minMatches) * recipeOutputCount;
    }

    static fun transformRecipeIntoItemMap(recipe : List) : Map {
        // transform recipe into item map, apply lambda x -> x.getFullId() to each item in recipe, then generate Frequency Map with simple code.
        frequencyMap = {};
        // if access is null, initialize it to 1, else increment it by 1.
        foreach (item : recipe) {
            // if item is null, continue
            if (item == null) {
                continue;
            }
            if (frequencyMap[item.getFullId()] == null) {
                frequencyMap[item.getFullId()] = 1;
            } else {
                frequencyMap[item.getFullId()] += 1;
            }
        }
        return frequencyMap;
    }

}

class Suggester {
    static var RECIPE = Recipe.ALL.filter(fun (recipe) {
        // filter recipes by getCraftingType == 'crafting'
        return recipe.getCraftingType() == 'crafting';
    }).map(fun(recipe) {
        // get recipe full id
        return recipe.getFullId();
    });
    // Suggester is a class that suggests things.
    static var TRACE_X = fun (args...) {
        // suggest x from trace
        return [Player.get().getLookingAtBlock(RESTRICTION_MAP["reach_distance"]).getPos().getX()];
    };
    static var TRACE_Y = fun (args...) {
        // suggest y from trace
        return [Player.get().getLookingAtBlock(RESTRICTION_MAP["reach_distance"]).getPos().getY()];
    };
    static var TRACE_Z = fun (args...) {
        // suggest z from trace
        return [Player.get().getLookingAtBlock(RESTRICTION_MAP["reach_distance"]).getPos().getZ()];
    };
}

new GameEvent('onClientTick', fun(){
    ScreenInventory.resetClickCount();
}).register();
// we register onOpenScreen callback to cache inventory when player opens inventory.
// we can use this to get inventory from cache, and search for item.
// first we might have interactBlock callback, that caches where player interacted.
// then if screen is opened, we can get inventory from cache, and search for item.
new GameEvent('onInteractBlock', fun(block, itemStack) {
    // modify LastInteractedBlockPos
    // if ContainerInventory.allowCache is false, return
    if (!ContainerInventory.allowCache) return;
    LastInteractedBlockPos = block.getPos();
}).register();

new GameEvent('onOpenScreen', fun(screen) {
    // we will wrap with MinecraftTask that executes after some ticks, to sync screen.
    // if LastInteractedBlockPos is not null, we can create inventory and register to cache.
    if (LastInteractedBlockPos == null) return;
    sleep(ScreenInventory.WAIT_TIME * 600); // we wait for sync, ensures its always smaller than *1000
    print(ScreenInventory.getCurrentScreenName());
    if (LastInteractedBlockPos != null) {
        // check if screen is inventory
        // iterate over ScreenInventory.WHITELISTED_SCREENS(map) to check if screen is inventory
        // compare keys
        foreach (key : ScreenInventory.WHITELISTED_SCREENS.getKeys()) {
            // check if screen is inventory
            if (screen.getName().contains(key)) {
                // construct inventory. ScreenInventory will just get inventory from current screen.
                inventory = new ScreenInventory();
                // cache inventory
                ContainerInventory.CACHE.put([Player.get().getWorld(), LastInteractedBlockPos], inventory); // .toContainerInventory() is not needed
                // debug
                // print('cached inventory by key ' + key + ' at ' + LastInteractedBlockPos);
                LastInteractedBlockPos = null;
                return;
            }
        }
    }
}).register();

// test nearby inventory search
//testSearchNearbyInventoryForItem('minecraft:stone');
// test nearby inventory search all
//searchNearbyInventoryForItemAllApplies('minecraft:stone', renderBox);

// lets define command
import LinearCommand from minecraft.CommandUtils;

// LinearCommand.register(args) does same stuff as new LinearCommand(args).process()
// if there is no argument - when its all literal, we can use single list for first argument, like this : LinearCommand.register(['eDemiBolt', 'x', 'y', 'z', 'direction', task]);
// but task must be last argument, and it should be function.
// example command : // new LinearCommand([['eDemiBolt'], ['x', 'Integer'], ['y', 'Integer'], ['z', 'Integer'], ['direction', 'Enum', Direction.type]], demiBoltTask).process();
// this is - new LinearCommand([[commandName], [argument1, argument1Type, suggestableIterable], [argument2, argument2Type, suggestableIterable], ...], task)
// all arguments should have unique names. Arguments must be packes as [[argumentName, argumentType, suggestableIterable], ...]], where suggestableIterable is optional.
// There is some exceptions as Integer, which can use min, max values as suggestableIterable.
// basically last argument is task, and other arguments are arguments for task.
// task is function that takes arguments as parameters.
// example task : // function demiBoltTask(x, y, z, direction) { print('x : ' + x + ', y : ' + y + ', z : ' + z + ', direction : ' + direction); }
// example command : // //eDemiBolt 1 2 3 north
// example output : // x : 1, y : 2, z : 3, direction : north
// The possible argument types are: 'PlayerName', 'Word' 'String', 'GreedyString', 'Double', 'Integer', 'Boolean', 'Enum', 'ItemStack', 'Block', 'Particle', 'RecipeId', 'EntityId', 'EnchantmentId', 'Entity', 'Entities', 'BlockPos', 'Pos', 'Effect', 'BiomeId'.

// here we just register simple command that accepts itemStack as argument, searchNearbyInventoryForItemAllApplies as task, and renderBox as applier.
// command name is searchInventory, argument name is item, argument type is ItemStack, and task is searchNearbyInventoryForItemAllApplies.
// applier is renderBox.
// thus we need to create lambda that automatically uses renderBox as applier.
// we can do this by using fun(args) { searchNearbyInventoryForItemAllApplies(args, renderBox); }

LinearCommand.register(['searchInventory','search', ['item', 'ItemStack']], fun(stack) { searchNearbyInventoryForItemAllApplies(stack.getId(), renderBox); });
// example command : searchInventory minecraft:stone
// lets make command that toggles ContainerInventory.allowCache, main command is searchInventory, and subcommand is toggleCache
// lets indicate that cache is enabled or disabled by printing message.
LinearCommand.register(['searchInventory', 'toggleCache'], fun() {
    ContainerInventory.allowCache = !ContainerInventory.allowCache;
    print('ContainerInventory.allowCache is ' + ContainerInventory.allowCache);
});
// lets use searchNearbyInventoryForItemAllCache function. subcommand is fromCache, and argument is item.
LinearCommand.register(['searchInventory', 'fromCache', ['item', 'ItemStack']], fun(stack) { searchNearbyInventoryForItemAllCache(stack.getId(), renderBox); });
// lets save ContainerInventory.CACHE to file
// here is example code to save and load json file.
/*
saveListTask = fun(){
   file = new File(File.getDirectory().getAbsolutePath() + '/scriptName.json');
   Json.fromMap(configs).writeToFile(file);
   player.message('File written to '+ file.getAbsolutePath());
};

loadListTask = fun(){
   file = new File(File.getDirectory().getAbsolutePath() + '/scriptName.json');
   configs = Json.fromString(file.read()).getValue();
   player.message('File loaded from '+ file.getAbsolutePath());
};
*/

// lets save STORAGE_LOCATIONS to file. its {WorldName : [Pos]}. We will convert it to {WorldName : [[x,y,z]]}.
// we will use Json.fromMap to convert it to json.

saveStorageLocationsTask = fun(){
   file = new File(File.getDirectory().getAbsolutePath() + '/' + SCRIPT_PREFIX + 'searchInventoryStorageLocations.json');
   // lets create storageLocationsObject, which will be converted to json.
   storageLocationsObject = {};
    // iterate over STORAGE_LOCATIONS, and convert Pos to [x,y,z] with pos.toList()
    foreach (key : STORAGE_LOCATIONS.getKeys()){
        // key is WorldName, and value is [Pos].
        // to save, lets nest {WorldName : [[x,y,z]]}.
        // if WorldName is not in storageLocationsObject, lets create it.
        if (!storageLocationsObject.containsKey(key)){
            storageLocationsObject.put(key, []);
        }
        // iterate over [Pos], and convert Pos to [x,y,z] with pos.toList()
        foreach (pos : STORAGE_LOCATIONS.get(key)){
            // add [x,y,z] to storageLocationsObject[WorldName].
            storageLocationsObject.get(key).add(pos.toList());
        }
    }
    Json.fromMap(storageLocationsObject).writeToFile(file);
};

// lets load STORAGE_LOCATIONS from file. its {WorldName : [Pos]}. We will convert it to {WorldName : [[x,y,z]]}.
// we will use Json.fromMap to convert it to json.

loadStorageLocationsTask = fun(){
   file = new File(File.getDirectory().getAbsolutePath() + '/' + SCRIPT_PREFIX + 'searchInventoryStorageLocations.json');
   if (!file.exists()){
         print('File does not exist.');
         return;
   }
   // lets create storageLocationsObject, which will be converted to json.
   storageLocationsObject = Json.fromString(file.read()).getValue();
   // lets create STORAGE_LOCATIONS, which will be converted to json.
   STORAGE_LOCATIONS = {};
    // iterate over storageLocationsObject, and convert [x,y,z] to Pos with new Pos(list)
    foreach (key : storageLocationsObject.getKeys()){
        // key is WorldName, and value is [[x,y,z]].
        // to save, lets nest {WorldName : [Pos]}.
        // if WorldName is not in STORAGE_LOCATIONS, lets create it.
        if (!STORAGE_LOCATIONS.containsKey(key)){
            STORAGE_LOCATIONS.put(key, []);
        }
        // iterate over [[x,y,z]], and convert [x,y,z] to Pos with new Pos(list)
        foreach (pos : storageLocationsObject.get(key)){
            // add Pos to STORAGE_LOCATIONS[WorldName].
            STORAGE_LOCATIONS.get(key).add(new Pos(pos));
        }
    }
};
// basic file save and load code.
// saveTask(optionName, optionValueSupplier) : saves optionValueSupplier() to file.
// loadTask(optionName, optionValueSetter) : loads file and calls optionValueSetter(value).
saveTask = fun(optionName, optionValueSupplier){
   file = new File(File.getDirectory().getAbsolutePath() + '/' + SCRIPT_PREFIX + optionName + '.json');
   Json.fromMap(optionValueSupplier()).writeToFile(file);
   player.message('File written to '+ file.getAbsolutePath());
};

loadTask = fun(optionName, optionValueSetter){
   file = new File(File.getDirectory().getAbsolutePath() + '/' + SCRIPT_PREFIX + optionName + '.json');
   if (!file.exists()){
         print('File does not exist.');
         return;
   }
   optionValueSetter(Json.fromString(file.read()).getValue());
   player.message('File loaded from '+ file.getAbsolutePath());
};


// lets generate command for saveStorageLocationsTask and loadStorageLocationsTask.
LinearCommand.register(['searchInventory', 'saveStorageLocations'], saveStorageLocationsTask);
LinearCommand.register(['searchInventory', 'loadStorageLocations'], loadStorageLocationsTask);
// lets generate command for addInventory and createStorage.
// addInventory is subcommand of searchInventory, and argument is x, y, z. Uses suggester of Suggester.TRACE_X / Y / Z
LinearCommand.register(['searchInventory', 'addInventory', ['x', 'Integer', Suggester.TRACE_X], ['y', 'Integer', Suggester.TRACE_Y], ['z', 'Integer', Suggester.TRACE_Z]], fun(x, y, z) {
    addInventory(new Pos(x, y, z));
});
// createStorage refreshed Storage from STORAGE_LOCATIONS. does not require any arguments.
LinearCommand.register(['searchInventory', 'refreshStorage'], fun() {
    createStorage();
});


// lets save ContainerInventory.CACHE to file
LinearCommand.register(['searchInventory', 'saveCache'], fun() {
    file = new File(File.getDirectory().getAbsolutePath() + '/' + SCRIPT_PREFIX + 'searchInventoryCache.json');
    // ContainerInventory.CACHE is map of [WorldName, BlockPos] to ContainerInventory.
    // but World and Container is not automatically serializable, so we need to convert it to json.
    // for ContainerInventory, it provides .toJson() method.
    cacheObject = {};
    // iterate over ContainerInventory.CACHE, call .toJson() on ContainerInventory, and put it to cacheObject.
    foreach (key : ContainerInventory.CACHE.getKeys()){
        // key is [WorldName, BlockPos], and value is ContainerInventory.
        // to save, lets nest {WorldName : {BlockPos : ContainerInventory.toJson()}}.
        // if WorldName is not in cacheObject, lets create it.
        if (!cacheObject.containsKey(key[0])){
            cacheObject.put(key[0], {});
        }
        // lets put ContainerInventory.toJson() to cacheObject.
        cacheObject.get(key[0]).put(key[1], ContainerInventory.CACHE.get(key).toJson());
    }
    Json.fromMap(cacheObject).writeToFile(file);
    print('File written to '+ file.getAbsolutePath());
});
// lets load ContainerInventory.CACHE from file
LinearCommand.register(['searchInventory', 'loadCache'], fun() {
    file = new File(File.getDirectory().getAbsolutePath() + '/' + SCRIPT_PREFIX + 'searchInventoryCache.json');
    // temporary cacheObject to load json file.
    // we need to convert it to ContainerInventory.CACHE.
    cacheObject = Json.fromString(file.read()).getValue();
    // clear ContainerInventory.CACHE
    ContainerInventory.CACHE.clear();
    // iterate over cacheObject, and put it to ContainerInventory.CACHE
    // cacheObject is {WorldName : {BlockPos : ContainerInventory.toJson()}}
    foreach (key : cacheObject.getKeys()){
        // key is WorldName, and value is {BlockPos : ContainerInventory.toJson()}
        // lets iterate over value.
        foreach (key2 : cacheObject.get(key).getKeys()){
            // key2 is "(x, y, z)", and value2 is ContainerInventory.toJson()
            // parse BlockPos from key2.
            // we need float x, y, z, so we need to parse it from string.
            // remove '(' and ')' by substring.
            parsedKey = key2.subString(1, len(key2) - 1);
            // lets split key2 by ','
            parsedKey = parsedKey.split(',');
            // now apply toNumber to each element of key2.
            parsedKey = parsedKey.map(fun (x) { return x.toNumber(); });
            parsedKey = new Pos(parsedKey);
            // lets put [WorldName, BlockPos] to ContainerInventory.CACHE, and ContainerInventory.fromJson(value2).
            ContainerInventory.CACHE.put([key, parsedKey], ContainerInventory.fromJson(cacheObject.get(key).get(key2)));
        }
    }
    print('File loaded from '+ file.getAbsolutePath());
});

// lets make command that clears ContainerInventory.CACHE aka cache
LinearCommand.register(['searchInventory', 'clearCache'], fun() {
    ContainerInventory.CACHE.clear();
    // print out that cache is cleared.
    print('Inventory caches are cleared.');
});

// lets try parsing player inventory by ScreenInventory.ofPlayerInventory()
// lets make command that prints player inventory.
LinearCommand.register(['searchInventory', 'printPlayerInventory'], fun() {
    // lets get player inventory.
    inventory = ScreenInventory.ofPlayerInventory().get();
    // lets print items of player inventory.
    print(inventory.getItemMap());
});

// lets make command that moves item from player inventory to chest. we will use ItemManager.moveToPos function.
// suggets x, y, z by suggester.
LinearCommand.register(['searchInventory', ['moveItemToChest'], ['item', 'ItemStack'], ['x', 'Integer', Suggester.TRACE_X], ['y', 'Integer', Suggester.TRACE_Y], ['z', 'Integer', Suggester.TRACE_Z],
    ['amount', 'Integer']], fun(stack, x, y, z, amount) {
    // use static function
    pos = new Pos(x, y, z);
    ItemManager.moveToPos(pos, stack, amount);
});
// now lets try reverse function, move item from chest to player inventory.
// lets make command that moves item from chest to player inventory. we will use ItemManager.moveFromPos function.
// suggets x, y, z by suggester.
LinearCommand.register(['searchInventory', ['moveItemFromChest'], ['item', 'ItemStack'], ['x', 'Integer', Suggester.TRACE_X], ['y', 'Integer', Suggester.TRACE_Y], ['z', 'Integer', Suggester.TRACE_Z],
    ['amount', 'Integer']], fun(stack, x, y, z, amount) {
    // use static function
    pos = new Pos(x, y, z);
    ItemManager.moveFromPos(pos, stack, amount);
});

// lets use Area version of moving items
// with ItemManager.moveToNearby / moveFromNearby, we can move items from/to nearby chest.
// lets make command that moves item from player inventory to nearby chest. we will use ItemManager.moveToNearby function.
// we don't need x, y, z, because we will use nearby chest.
LinearCommand.register(['searchInventory', ['moveItemToNearbyChest'], ['item', 'ItemStack'], ['amount', 'Integer']], fun(stack, amount) {
    // use static function
    ItemManager.moveToNearby(stack, amount);
});
// lets make command that moves item from nearby chest to player inventory. we will use ItemManager.moveFromNearby function.
// we don't need x, y, z, because we will use nearby chest.
// example command : searchInventory moveItemFromNearbyChest minecraft:stone 64
LinearCommand.register(['searchInventory', ['moveItemFromNearbyChest'], ['item', 'ItemStack'], ['amount', 'Integer']], fun(stack, amount) {
    // use static function
    ItemManager.moveFromNearby(stack, amount);
});

// lets get nearby inventories then register them to STORAGE. getNearbyInventory returns [Pos,...]
// lets make command that gets nearby inventories and register them to STORAGE. We don't need arguments.
LinearCommand.register(['searchInventory', 'registerNearbyStorage'], fun() {
    // use static function
    // if STORAGE is not initialized, initialize it.
    if (STORAGE == null) {
        createStorage();
    }
    // get nearby inventories.
    inventories = getNearbyInventory();
    // iterate and register to STORAGE.
    foreach (pos : inventories) {
        STORAGE.addInventory(pos);
    }
    // print out that STORAGE is created.
    print('Storage is created.');
});


// lets make command that moves from / to STORAGE variable. STORAGE is MergedInventory, it has moveTo, moveFrom functions that can replace moveToNearby, moveFromNearby.
// lets make command that moves item from player inventory to STORAGE. we will use MergedInventory.moveTo function.
// we don't need x, y, z, because we will use STORAGE.
LinearCommand.register(['searchInventory', ['moveItemToStorage'], ['item', 'ItemStack'], ['amount', 'Integer']], fun(stack, amount) {
    // use static function
    // if STORAGE is not initialized, initialize it.
    if (STORAGE == null) {
        createStorage();
    }
    STORAGE.moveTo(stack, amount);
});
// lets make command that moves item from STORAGE to player inventory. we will use MergedInventory.moveFrom function.
// we don't need x, y, z, because we will use STORAGE.
// example command : searchInventory moveItemFromStorage minecraft:stone 64
LinearCommand.register(['searchInventory', ['moveItemFromStorage'], ['item', 'ItemStack'], ['amount', 'Integer']], fun(stack, amount) {
    // use static function
    // if STORAGE is not initialized, initialize it.
    if (STORAGE == null) {
        createStorage();
    }
    STORAGE.moveFrom(stack, amount);
});

// TODO
// fix current count matching, it is not working properly.
// add Color render function, maybe we can use fixed global 'color' variable and change by command.

// MergedInventory provides getAllAccessibleItems and getAllItems functions.
// lets make command that prints all accessible items using variable STORAGE 
// example command : searchInventory printAllAccessibleItems
LinearCommand.register(['searchInventory', 'storage', 'printAllAccessibleItems'], fun() {
    // lets get all accessible items.
    // if STORAGE is not initialized, initialize it.
    if (STORAGE == null) {
        createStorage();
    }
    items = STORAGE.getAllAccessibleItems();
    // lets print items.
    print(StringUtil.pretty(items, '    '));
});

// lets make command that prints all items using variable STORAGE
// example command : searchInventory printAllItems
LinearCommand.register(['searchInventory', 'storage', 'printAllItems'], fun() {
    // lets get all items.
    // if STORAGE is not initialized, initialize it.
    if (STORAGE == null) {
        createStorage();
    }
    items = STORAGE.getAllItems();
    // lets print items. For complex map / list, we can use pretty function.
    print(StringUtil.pretty(items, '    '));
});

// lets debug how recipe works, by inspecting Recipe.of(recipeName) method.
// lets make command that prints recipe of wanted item, by taking it as Word argument that suggests RecipeManager.RECIPES.
LinearCommand.register(['recipeManager', ['printRecipe'], ['item', 'RecipeId', Suggester.RECIPE]], fun(item) {
    // lets get recipe of item.
    recipe = Recipe.of(item);
    // lets print recipe's getIngredients, getCraftingType, getOutput
    print('Ingredients : ');
    print(StringUtil.pretty(recipe.getIngredients(), '    '));
    print('CraftingType : '+ recipe.getCraftingType());
    print('Output : '+ recipe.getOutput());
});

// lets test StrictRecipe.findStrictRecipe(recipe) function and print out result.
// command : recipeManager findStrictRecipe minecraft:stone
LinearCommand.register(['recipeManager', ['findStrictRecipe'], ['item', 'RecipeId', Suggester.RECIPE]], fun(item) {
    // lets get recipe of item.
    recipe = Recipe.of(item);
    // lets get strict recipe.
    strictRecipe = StrictRecipe.findStrictRecipe(recipe);
    // if strict recipe is null, print out that it is not found.
    if (strictRecipe == null) {
        print('Strict recipe is not found.');
        return;
    }
    // lets print strict recipe's getIngredients, getCraftingType, getOutput
    print('Ingredients : ');
    print(StringUtil.pretty(strictRecipe.getIngredients(), '    '));
    print('CraftingType : '+ strictRecipe.getCraftingType());
    print('Output : '+ strictRecipe.getOutput());
});
// lets test StrictRecipe.findStrictRecipe(recipe, MergedInventory.ofNearby()) function and print out result.
// command : recipeManager findStrictRecipeNearby minecraft:stone
LinearCommand.register(['recipeManager', ['findStrictRecipeNearby'], ['item', 'RecipeId', Suggester.RECIPE]], fun(item) {
    // lets get recipe of item.
    recipe = Recipe.of(item);
    // lets get strict recipe.
    strictRecipe = StrictRecipe.findStrictRecipe(recipe, MergedInventory.ofNearby());
    // if strict recipe is null, print out that it is not found.
    if (strictRecipe == null) {
        print('Strict recipe is not found.');
        return;
    }
    // lets print strict recipe's getIngredients, getCraftingType, getOutput
    print('Ingredients : ');
    print(StringUtil.pretty(strictRecipe.getIngredients(), '    '));
    print('CraftingType : '+ strictRecipe.getCraftingType());
    print('Output : '+ strictRecipe.getOutput());
});

// lets test RecipeManager.tryCraftItem(item, amount) function and print out crafted amount.
// command : recipeManager tryCraftItem minecraft:stone 64
LinearCommand.register(['recipeManager', ['tryCraftItem'], ['item', 'RecipeId', Suggester.RECIPE], ['amount', 'Integer']], fun(item, amount) {
    craftedAmount = RecipeManager.tryCraftItem(item, amount);
    // lets print crafted amount.
    print('Crafted amount : '+ craftedAmount + ' for '+ item);
});

// lets test CraftingPlan.of(item, amount) function then use plan.pretty() function to print out crafting plan.
// command : recipeManager printCraftingPlan minecraft:stone 64
LinearCommand.register(['recipeManager', ['printCraftingPlan'], ['item', 'RecipeId', Suggester.RECIPE], ['amount', 'Integer']], fun(item, amount) {
    // lets get crafting plan.
    plan = CraftingPlan.of(item, amount);
    // lets print crafting plan.
    plan.pretty();
});

// .ofNearby() function is same as .of() function, but it uses nearby chest.
// lets test CraftingPlan.ofNearby(item, amount) function then use plan.pretty() function to print out crafting plan.
// command : recipeManager printCraftingPlanNearby minecraft:stone 64
LinearCommand.register(['recipeManager', ['printCraftingPlanNearby'], ['item', 'RecipeId', Suggester.RECIPE], ['amount', 'Integer']], fun(item, amount) {
    // lets get crafting plan.
    plan = CraftingPlan.ofNearby(item, amount);
    // lets print crafting plan.
    plan.pretty();
});

// then we can call .craft() function to craft item.
// lets test CraftingPlan.craft() function then use plan.pretty() function to print out crafting plan.
// command : recipeManager craftItem minecraft:stone 64
LinearCommand.register(['recipeManager', ['craftItem'], ['item', 'RecipeId', Suggester.RECIPE], ['amount', 'Integer']], fun(item, amount) {
    // lets get crafting plan.
    plan = CraftingPlan.of(item, amount);
    // lets craft item.
    if (plan.isCraftable) plan.craft();
    // lets print crafting plan.
    plan.pretty();
});

// lets test CraftingPlan.craft() function then use plan.pretty() function to print out crafting plan.
// command : recipeManager craftItemNearby minecraft:stone 64
LinearCommand.register(['recipeManager', ['craftItemNearby'], ['item', 'RecipeId', Suggester.RECIPE], ['amount', 'Integer']], fun(item, amount) {
    // lets get crafting plan.
    plan = CraftingPlan.ofNearby(item, amount);

    print(plan);
    // debug generated inventory
    //print(plan.inventory);
    // lets craft item.
    if (plan.isCraftable) plan.craft();
    // lets print crafting plan.
    plan.pretty();
});

// lets test RecipeManager.findContainsId(itemId) function and print out result.
// command : recipeManager findContainsId minecraft:stone
LinearCommand.register(['recipeManager', ['findContainsId'], ['item', 'ItemStack']], fun(item) {
    containsId = RecipeManager.findContainsId(item.getFullId());
    // lets print contains id.
    print('Contains id : '+ containsId);
});

// and match version with findMatchingId(itemId) function.
// lets test RecipeManager.findMatchingId(itemId) function and print out result.
// command : recipeManager findMatchingId minecraft:stone
LinearCommand.register(['recipeManager', ['findMatchingId'], ['item', 'ItemStack']], fun(item) {
    matchingId = RecipeManager.findMatchingId(item.getFullId());
    // lets print matching id.
    print('Matching id : '+ matchingId);
});

// Lets create a command that can change restriction map.
// command : recipeManager setRestriction reach_distance 5
LinearCommand.register(['recipeManager', ['setRestriction'], ['number', 'Word', fun (arg...) {
    // suggests if key is in RESTRICTION_MAP and type is Number.
    return RESTRICTION_MAP.getKeys().filter(fun(key) {
        return RESTRICTION_MAP[key].instanceOf(Number.type);
    });
}], ['double', 'Double', 0, 100]], fun(key, value) {
    // lets set value to restriction map.
    RESTRICTION_MAP[key] = value;
    // lets print out result.
    print('Set '+ key +' to '+ value);
});
// now for Boolean
// command : recipeManager setRestriction use_actionbar true
LinearCommand.register(['recipeManager', ['setRestriction'], ['boolean', 'Word', fun (arg...) {
    // suggests if key is in RESTRICTION_MAP and type is Boolean.
    return RESTRICTION_MAP.getKeys().filter(fun(key) {
        return RESTRICTION_MAP[key].instanceOf(Boolean.type);
    });
}], ['option', 'Boolean']], fun(key, value) {
    // lets set value to restriction map.
    RESTRICTION_MAP[key] = value;
    // lets print out result.
    print('Set '+ key +' to '+ value);
});
// RecipeManager, modify SELECTED_RECIPES with following static functions
    // suggestSelectedRecipe() : return list of fullId of SELECTED_RECIPES
    // resetSelectedRecipes() : reset SELECTED_RECIPES to ALL_RECIPES
    // emptyRecipes() : empty SELECTED_RECIPES
    // addRecipe(recipe : Recipe) : add recipe to SELECTED_RECIPES
    // removeRecipe(recipe : Recipe) : remove recipe from SELECTED_RECIPES
    // addRecipeOfPlayer() : add all recipes that can be crafted with items in player's inventory
    // addRecipeOfNearby() : add all recipes that can be crafted with items in nearby inventories
    // addRecipeOfItem(item : ItemStack) : add all recipes that can be crafted with given item
    // addRecipeOf(string : String) : add all recipes that can be crafted with given item

// lets make command that calls RecipeManager.resetSelectedRecipes() function. 
// we will use selectRecipes <function> command.
// command : recipeManager selectRecipes resetSelectedRecipes
LinearCommand.register(['recipeManager', 'selectRecipes', 'resetSelectedRecipes'], fun() {
    // lets reset selected recipes.
    RecipeManager.resetSelectedRecipes();
    // lets print out result.
    print('Reset selected recipes.');
});

// lets make command that calls RecipeManager.emptyRecipes() function.
// command : recipeManager selectRecipes emptyRecipes
LinearCommand.register(['recipeManager', 'selectRecipes', 'emptyRecipes'], fun() {
    // lets empty selected recipes.
    RecipeManager.emptyRecipes();
    // lets print out result.
    print('Emptied selected recipes.');
});

// lets make command that calls RecipeManager.addRecipeOfPlayer() function. We will name it 'addRecipeOfPlayer'.
// command : recipeManager selectRecipes addRecipeOfPlayer
LinearCommand.register(['recipeManager', 'selectRecipes', 'addRecipeOfPlayer'], fun() {
    // lets add recipe of player.
    RecipeManager.addRecipeOfPlayer();
    // lets print out result.
    print('Added recipe of player inventory.');
});

// lets make command that calls RecipeManager.addRecipeOfNearby() function. We will name it 'addRecipeOfNearby'.
// command : recipeManager selectRecipes addRecipeOfNearby
LinearCommand.register(['recipeManager', 'selectRecipes', 'addRecipeOfNearby'], fun() {
    // lets add recipe of nearby.
    RecipeManager.addRecipeOfNearby();
    // lets print out result.
    print('Added recipe of nearby inventories.');
});

// lets make command that calls RecipeManager.addRecipeOfItem(item : ItemStack) function. We will name it 'addRecipeOfItem'.
// command : recipeManager selectRecipes addRecipeOfItem minecraft:stone
LinearCommand.register(['recipeManager', 'selectRecipes', 'addRecipeOfItem', ['item', 'ItemStack']], fun(item) {
    // lets add recipe of item.
    RecipeManager.addRecipeOfItem(item);
    // lets print out result.
    print('Added recipe of item '+ item.getFullId() +'.');
});

// lets make command that calls RecipeManager.addRecipeOf(string : String) function. We will name it 'addRecipeOf'.
// command : recipeManager selectRecipes addRecipeOf minecraft:stone
LinearCommand.register(['recipeManager', 'selectRecipes', 'addRecipeOf', ['item', 'ItemStack']], fun(item) {
    // lets add recipe of item.
    RecipeManager.addRecipeOf(item.getFullId());
    // lets print out result.
    print('Added recipe of item '+ item.getFullId() +'.');
});

// lets make command that calls RecipeManager.addRecipe(recipe : Recipe) function. We will name it 'addRecipe'.
// command : recipeManager selectRecipes addRecipe minecraft:stone
LinearCommand.register(['recipeManager', 'selectRecipes', 'addRecipe', ['item', 'Recipe']], fun(item) {
    // lets add recipe of item.
    RecipeManager.addRecipe(item);
    // lets print out result.
    print('Added recipe '+ item.getFullId() +'.');
});

// lets make command that calls RecipeManager.removeRecipe(recipe : Recipe) function. We will name it 'removeRecipe'.
// command : recipeManager selectRecipes removeRecipe minecraft:stone
LinearCommand.register(['recipeManager', 'selectRecipes', 'removeRecipe', ['item', 'Recipe', RecipeManager.suggestSelectedRecipe]], fun(item) {
    // lets remove recipe of item.
    RecipeManager.removeRecipe(item);
    // lets print out result.
    print('Removed recipe '+ item.getFullId() +'.');
});

// lets save SELECTED_RECIPES to file.
// command : recipeManager saveRecipes
LinearCommand.register(['recipeManager', 'saveRecipes'], fun() {
    // lets save selected recipes.
    RecipeManager.saveRecipes();
    // lets print out result.
    print('Saved selected recipes.');
});

// lets load SELECTED_RECIPES from file.
// command : recipeManager loadRecipes
LinearCommand.register(['recipeManager', 'loadRecipes'], fun() {
    // lets load selected recipes.
    RecipeManager.loadRecipes();
    // lets print out result.
    print('Loaded selected recipes.');
});

// lets explain how to use recipeManager selectRecipes <function> command, by recimeManager selectRecipes command.
// command : recipeManager selectRecipes
// we will list all subcommands that can be used with selectRecipes command, with short description.
LinearCommand.register(['recipeManager', 'selectRecipes'], fun() {
    // lets print out result.
    print('Caches recipes for faster searching.');
    print('Usage : recipeManager selectRecipes <function>');
    print('Functions :');
    print('resetSelectedRecipes : reset SELECTED_RECIPES to ALL_RECIPES');
    print('emptyRecipes : empty SELECTED_RECIPES');
    print('addRecipeOfPlayer : add all recipes that can be crafted with items in player inventory');
    print('addRecipeOfNearby : add all recipes that can be crafted with items in nearby inventories');
    print('addRecipeOfItem <item> : add all recipes that can be crafted with given item');
    print('addRecipeOf <item> : add all recipes that can be crafted with given item');
    print('addRecipe <recipe> : add given recipe to SELECTED_RECIPES');
    print('removeRecipe <recipe> : remove given recipe from SELECTED_RECIPES');
    print('saveRecipes : save SELECTED_RECIPES to file');
    print('loadRecipes : load SELECTED_RECIPES from file');
});

print("recipemanager / searchInventory commands are loaded!");
print("To craft item, use /recipeManager craftItem(Nearby) <item> command.");
print("To search item, use /searchInventory search <item> command.");
hold();