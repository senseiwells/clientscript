import * from Minecraft;
import * from minecraft.CommandUtils;

client = MinecraftClient.getClient();
player = client.getPlayer();
world = client.getWorld();
enabled = true;
workInterval = -1;
minY = -65;
maxY = 384;
maxInteractBlockPerTick = 20;
reachDistance = 6;
currentTick = 0;
wasWorking = false;
disposables = {
    'bone_meal' : true
};
usables = {};
predicateProperties = {};


autoPause = true;

new GameEvent("onDimensionChange", fun(newWorld) {
    player = client.getPlayer();
    world = newWorld;
    wasWorking = false;
}).register();

new GameEvent("onClientTick", fun() {
    if (!enabled) return;
    currentTick++;
}).register();

predicates = {};
predicatesLevel = {};
harvestAddition = {};
setReachDistance = fun(newReach) {
    reachDistance = newReach;
};
checkId = fun(itemId) {
    foreach(keys : disposables.getKeys()){
        if (itemId == keys) return true;
    }
    return false;
};
checkAdditionalId = fun(itemId) {
    foreach(keys : usables.getKeys()){
        if (itemId == keys) return true;
    }
    return false;
};
checkAutopause = fun(){
    if (!autoPause) return;
    item = player.getHeldItem();
    if (checkId(item.getId()) && item.getCount() > 0){
        return;
    }
    enabled = false;
    player.message('Stopped because no disposable item was found!');
};
interactBlockIfAdditional = fun(pos) {
    block = world.getBlockAt(pos);
    if (predicateBlockAddition(block)) {
        try {
            interactBlock(pos);
            checkAutopause();
        }
        catch (e){
            null;
        }
        return true;
    }
    return false;
};
interactBlockIf = fun(pos) {
    block = world.getBlockAt(pos);
    if (predicateBlock(block)) {
        try {
            interactBlock(pos);
            checkAutopause();
        }
        catch (e){
            null;
        }
        return true;
    }
    return false;
};
predicateBlockAddition = fun(block) {

};
fun interactBlock(pos){
    //we need library for this?
    player.messageActionBar('Interacting block at '+ pos);
    player.interactBlock(pos, 'UP');
}
setMinYTask = fun(newY){
    minY = newY;
};
setMaxYTask = fun(newY){
    maxY = newY;
};
checkRadius = fun() {
    playerPos = player.getPos();
    current = 0;
    checkAutopause();
    // foreach (pos : world.getPositionsFromCentre(playerPos, reachDistance, reachDistance, reachDistance)){ Sensei wtf?

    //replacement code start
    x, y, z = playerPos.toList();
    sx, sy, sz = [x - reachDistance, Math.min(maxY, Math.max(minY, y - reachDistance)), z - reachDistance];
    ex, ey, ez = [x + reachDistance, Math.min(maxY, Math.max(minY, y + reachDistance)), z + reachDistance];
    foreach (pos : world.getPositions(new Pos(sx, sy, sz), new Pos(ex, ey, ez))){
    //end
        if (pos.distanceTo(playerPos) <= reachDistance && interactBlockIf(pos)){
            current ++;
        }
        if (!enabled || current >= maxInteractBlockPerTick){
            return;
        }
    }
};

isInReach = fun(target) {
    playerPos = player.getPos();
    return target.distanceTo(playerPos) < reachDistance;
};
fun predicateBlock(blocks) {
    blockId = blocks.getId();
    foreach (block : predicates.getKeys()) {
        isExact = predicates.get(block);
        optionalLevel = predicatesLevel.get(block);
        if (isExact == null) return false;
        if (isExact) {
            if (block == blockId) {
                //player.messageActionBar('found block');
                return matchBlockPropertyAge(blocks, optionalLevel) && requiresProperty(blocks);
            }
        }
        else {
            if (blockId.contains(block)) {
                return matchBlockPropertyAge(blocks, optionalLevel) && requiresProperty(blocks);
            }
        }
    }
    return false;
}

fun requiresProperty(block) {
    prop = block.getBlockProperties();
    requiredPropertyMap = predicateProperties.get(block.getId());
    if (requiredPropertyMap != null) {
        foreach(keys : requiredPropertyMap.getKeys()){
            if (prop.get(keys) == null) continue;
            if (prop.get(keys).toString() != requiredPropertyMap.get(keys)) return false;
        }
    }
    return true;
}
fun matchBlockPropertyAge(block, lvl) {
    if (lvl == null) return true;
    prop = block.getBlockProperties();
    return prop.get('age') != null && prop.get('age') < lvl;
}

addPredicate = fun(blockName, isExact) {
    predicates.put(blockName, isExact);
    player.message('Added ' + blockName + ' , exact matching : '+ isExact);
};
addPredicateLvl = fun(blockName, isExact, lvl) {
    predicates.put(blockName, isExact);
    predicatesLevel.put(blockName, lvl);
    player.message('Added ' + blockName + ' , exact matching : '+ isExact);
};
addPredicateLvlProperty = fun(blockName, isExact, lvl, propertyName, propertyValue) {
    predicates.put(blockName, isExact);
    predicatesLevel.put(blockName, lvl);
    predicateProperties.put(blockName, {propertyName: propertyValue});
    player.message('Added ' + blockName + ' , exact matching : '+ isExact);
};
removePredicate = fun(blockName) {
    if(predicates.get(blockName) == null) return;
    predicates.remove(blockName);
    predicatesLevel.remove(blockName);
    predicateProperties.remove(blockName);
    player.message('Removed '+ blockName);
};

setEnabledTask = fun(newEnabled) {
    enabled = newEnabled;
    player.message('Now feeder is set to '+ newEnabled);
};
toggleTask = fun() {
    player = client.getPlayer();
    world = client.getWorld();
    newEnabled = !enabled;
    setEnabledTask(newEnabled);
};
toggleAutoPauseTask = fun() {
    autoPause = !autoPause;
    player.message('Will pause when inventory has no disposables : ' + autoPause);
};

setWorkIntervalTask = fun(newInterval) {
    workInterval = newInterval;
    player.message('Now working every '+ newInterval + 'ms');
};

setMaxActionsTask = fun (newLimit) {
    maxInteractBlockPerTick = newLimit;
    player.message('Now max block interact count is set to '+ newLimit);
};

suggesterRemove = fun(args...) {
    return predicates.getKeys();
};

print("Bonemeal Spammer loaded with /grow command");
new LinearCommand([['grow'], ['minY'], ['value', 'Integer', -999, 999]], setMinYTask).process();
new LinearCommand([['grow'], ['maxY'], ['value', 'Integer', -999, 999]], setMaxYTask).process();
new LinearCommand([['grow'],['enabled', 'Boolean']], setEnabledTask).process();
new LinearCommand([['grow'], ['reachDistance'], ['reach', 'Integer', 1, 100]], setReachDistance).process();
new LinearCommand([['grow']], toggleTask).process();
new LinearCommand([['grow'], ['autoPause']], toggleAutoPauseTask).process();
new LinearCommand([['grow'],['add'], ['block', 'Word', DefaultSuggester.BLOCKS], ['exact', 'Boolean']], addPredicate).process();
// Will match age < maxage 
new LinearCommand([['grow'],['add'], ['block', 'Word', DefaultSuggester.BLOCKS], ['exact', 'Boolean'], ['maxage', 'Integer', 1, 10]], addPredicateLvl).process();
new LinearCommand([['grow'],['add'], ['block', 'Word', DefaultSuggester.BLOCKS], ['exact', 'Boolean'], ['maxage', 'Integer', 1, 10], ['propertyName', 'Word'], ['propertyValue', 'Word']], addPredicateLvlProperty).process();
new LinearCommand([['grow'],['remove'], ['block', 'Word', suggesterRemove]], removePredicate).process();
new LinearCommand([['grow'],['workInterval'], ['ms', 'Integer', -1, 500]], setWorkIntervalTask).process();
new LinearCommand([['grow'],['maxActions'], ['count', 'Integer', 0, 500]], setMaxActionsTask).process();
while (true) {
    if (!enabled) {
        sleep(50);
        continue;
    }
    if (workInterval <= 0 || workInterval == 0 || Math.mod(currentTick, workInterval) == 0) {
        checkRadius();
    }
    sleep(50);
}